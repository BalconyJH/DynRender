from typing import Any, ClassVar, Iterable, Iterator, List, Tuple

from typing import overload
import datetime
import numpy
AlphaOPAQUE: int
AlphaTRANSPARENT: int
ColorBLACK: int
ColorBLUE: int
ColorCYAN: int
ColorDKGRAY: int
ColorGRAY: int
ColorGREEN: int
ColorLTGRAY: int
ColorMAGENTA: int
ColorRED: int
ColorTRANSPARENT: int
ColorWHITE: int
ColorYELLOW: int
k2D: GrTextureType
kA: ColorChannel
kA16_float_ColorType: ColorType
kA16_unorm_ColorType: ColorType
kABGR_4444: GrColorType
kALL_GrGLBackendState: GrGLBackendState
kALPHA8: GrGLFormat
kARGB_4444_ColorType: ColorType
kASTC: EncodedImageFormat
kAlpha_16: GrColorType
kAlpha_8: GrColorType
kAlpha_8_ColorType: ColorType
kAlpha_8xxx: GrColorType
kAlpha_ColorChannelFlag: ColorChannelFlag
kAlpha_F16: GrColorType
kAlpha_F32xxx: GrColorType
kApprox: BackingFit
kB: ColorChannel
kBGRA8: GrGLFormat
kBGRA_1010102_ColorType: ColorType
kBGRA_8888: GrColorType
kBGRA_8888_ColorType: ColorType
kBGR_101010x_ColorType: ColorType
kBGR_565: GrColorType
kBGR_H_PixelGeometry: PixelGeometry
kBGR_V_PixelGeometry: PixelGeometry
kBMP: EncodedImageFormat
kBT2020_YUVColorSpace: YUVColorSpace
kBlend_GrGLBackendState: GrGLBackendState
kBlue_ColorChannelFlag: ColorChannelFlag
kBottomLeft_EncodedOrigin: EncodedOrigin
kBottomLeft_GrSurfaceOrigin: GrSurfaceOrigin
kBottomRight_EncodedOrigin: EncodedOrigin
kCCW: PathDirection
kCOMPRESSED_ETC1_RGB8: GrGLFormat
kCOMPRESSED_RGB8_BC1: GrGLFormat
kCOMPRESSED_RGB8_ETC2: GrGLFormat
kCOMPRESSED_RGBA8_BC1: GrGLFormat
kCW: PathDirection
kClamp: TileMode
kClear: BlendMode
kClose: PathVerb
kCoeffCount: BlendModeCoeff
kColor: BlendMode
kColorBurn: BlendMode
kColorDodge: BlendMode
kConic: PathVerb
kConic_PathSegmentMask: PathSegmentMask
kCubic: PathVerb
kCubic_PathSegmentMask: PathSegmentMask
kDA: BlendModeCoeff
kDC: BlendModeCoeff
kDNG: EncodedImageFormat
kDarken: BlendMode
kDawn: GrBackendApi
kDecal: TileMode
kDefault_EncodedOrigin: EncodedOrigin
kDifference: ClipOp
kDifference_PathOp: PathOp
kDirect3D: GrBackendApi
kDst: BlendMode
kDstATop: BlendMode
kDstIn: BlendMode
kDstOut: BlendMode
kDstOver: BlendMode
kDualSrcBlend_GrVkFeatureFlag: GrVkFeatureFlags
kEXT_debug_report_GrVkExtensionFlag: GrVkExtensionFlags
kEvenOdd: PathFillType
kExact: BackingFit
kExclusion: BlendMode
kExternal: GrTextureType
kFixedFunction_GrGLBackendState: GrGLBackendState
kFull: FontHinting
kG: ColorChannel
kGIF: EncodedImageFormat
kGeometryShader_GrVkFeatureFlag: GrVkFeatureFlags
kGlyphID: TextEncoding
kGray_8: GrColorType
kGray_8_ColorType: ColorType
kGray_8xxx: GrColorType
kGray_ColorChannelFlag: ColorChannelFlag
kGray_F16: GrColorType
kGreen_ColorChannelFlag: ColorChannelFlag
kHEIF: EncodedImageFormat
kHardLight: BlendMode
kHigh_FilterQuality: FilterQuality
kHue: BlendMode
kICO: EncodedImageFormat
kIDA: BlendModeCoeff
kIDC: BlendModeCoeff
kISA: BlendModeCoeff
kISC: BlendModeCoeff
kIdentity_YUVColorSpace: YUVColorSpace
kInner_BlurStyle: BlurStyle
kIntersect: ClipOp
kIntersect_PathOp: PathOp
kInverseEvenOdd: PathFillType
kInverseWinding: PathFillType
kJPEG: EncodedImageFormat
kJPEG_YUVColorSpace: YUVColorSpace
kKHR_android_surface_GrVkExtensionFlag: GrVkExtensionFlags
kKHR_surface_GrVkExtensionFlag: GrVkExtensionFlags
kKHR_swapchain_GrVkExtensionFlag: GrVkExtensionFlags
kKHR_win32_surface_GrVkExtensionFlag: GrVkExtensionFlags
kKHR_xcb_surface_GrVkExtensionFlag: GrVkExtensionFlags
kKTX: EncodedImageFormat
kLUMINANCE16F: GrGLFormat
kLUMINANCE8: GrGLFormat
kLast: ConvergeMode
kLastCoeffMode: BlendMode
kLastEnum: ColorChannel
kLastEnum_AlphaType: AlphaType
kLastEnum_BlurStyle: BlurStyle
kLastEnum_YUVColorSpace: YUVColorSpace
kLastMode: BlendMode
kLastSeparableMode: BlendMode
kLastTileMode: TileMode
kLast_EncodedOrigin: EncodedOrigin
kLast_FilterQuality: FilterQuality
kLeftBottom_EncodedOrigin: EncodedOrigin
kLeftTop_EncodedOrigin: EncodedOrigin
kLighten: BlendMode
kLine: PathVerb
kLine_PathSegmentMask: PathSegmentMask
kLow_FilterQuality: FilterQuality
kLuminosity: BlendMode
kMSAAEnable_GrGLBackendState: GrGLBackendState
kMedium_FilterQuality: FilterQuality
kMetal: GrBackendApi
kMirror: TileMode
kMisc_GrGLBackendState: GrGLBackendState
kMock: GrBackendApi
kModulate: BlendMode
kMove: PathVerb
kMultiply: BlendMode
kN32_ColorType: ColorType
kNV_glsl_shader_GrVkExtensionFlag: GrVkExtensionFlags
kNo: Budgeted
kNone: GrTextureType
kNone_FilterQuality: FilterQuality
kNormal: FontHinting
kNormal_BlurStyle: BlurStyle
kOne: BlendModeCoeff
kOpaque_AlphaType: AlphaType
kOpenGL: GrBackendApi
kOpenGL_GrBackend: GrBackendApi
kOuter_BlurStyle: BlurStyle
kOverlay: BlendMode
kPKM: EncodedImageFormat
kPNG: EncodedImageFormat
kPathRendering_GrGLBackendState: GrGLBackendState
kPixelStore_GrGLBackendState: GrGLBackendState
kPlus: BlendMode
kPremul_AlphaType: AlphaType
kProgram_GrGLBackendState: GrGLBackendState
kQuad: PathVerb
kQuad_PathSegmentMask: PathSegmentMask
kR: ColorChannel
kR16: GrGLFormat
kR16F: GrGLFormat
kR16G16B16A16_unorm_ColorType: ColorType
kR16G16_float_ColorType: ColorType
kR16G16_unorm_ColorType: ColorType
kR8: GrGLFormat
kR8G8_unorm_ColorType: ColorType
kRG16: GrGLFormat
kRG16F: GrGLFormat
kRG8: GrGLFormat
kRGB10_A2: GrGLFormat
kRGB565: GrGLFormat
kRGB8: GrGLFormat
kRGBA16: GrGLFormat
kRGBA16F: GrGLFormat
kRGBA4: GrGLFormat
kRGBA8: GrGLFormat
kRGBA_1010102: GrColorType
kRGBA_1010102_ColorType: ColorType
kRGBA_16161616: GrColorType
kRGBA_8888: GrColorType
kRGBA_8888_ColorType: ColorType
kRGBA_8888_SRGB: GrColorType
kRGBA_ColorChannelFlags: ColorChannelFlag
kRGBA_F16: GrColorType
kRGBA_F16Norm_ColorType: ColorType
kRGBA_F16_Clamped: GrColorType
kRGBA_F16_ColorType: ColorType
kRGBA_F32: GrColorType
kRGBA_F32_ColorType: ColorType
kRGB_101010x_ColorType: ColorType
kRGB_565_ColorType: ColorType
kRGB_888: GrColorType
kRGB_888x: GrColorType
kRGB_888x_ColorType: ColorType
kRGB_ColorChannelFlags: ColorChannelFlag
kRGB_H_PixelGeometry: PixelGeometry
kRGB_V_PixelGeometry: PixelGeometry
kRG_1616: GrColorType
kRG_88: GrColorType
kRG_ColorChannelFlags: ColorChannelFlag
kRG_F16: GrColorType
kR_16: GrColorType
kR_8: GrColorType
kR_F16: GrColorType
kRec601_YUVColorSpace: YUVColorSpace
kRec709_YUVColorSpace: YUVColorSpace
kRectangle: GrTextureType
kRed_ColorChannelFlag: ColorChannelFlag
kRenderTarget_GrGLBackendState: GrGLBackendState
kRepeat: TileMode
kReverseDifference: ConvergeMode
kReverseDifference_PathOp: PathOp
kRightBottom_EncodedOrigin: EncodedOrigin
kRightTop_EncodedOrigin: EncodedOrigin
kSA: BlendModeCoeff
kSC: BlendModeCoeff
kSRGB8_ALPHA8: GrGLFormat
kSampleRateShading_GrVkFeatureFlag: GrVkFeatureFlags
kSaturation: BlendMode
kScreen: BlendMode
kSlight: FontHinting
kSoftLight: BlendMode
kSolid_BlurStyle: BlurStyle
kSrc: BlendMode
kSrcATop: BlendMode
kSrcIn: BlendMode
kSrcOut: BlendMode
kSrcOver: BlendMode
kStencil_GrGLBackendState: GrGLBackendState
kTextureBinding_GrGLBackendState: GrGLBackendState
kTopLeft_EncodedOrigin: EncodedOrigin
kTopLeft_GrSurfaceOrigin: GrSurfaceOrigin
kTopRight_EncodedOrigin: EncodedOrigin
kUTF16: TextEncoding
kUTF32: TextEncoding
kUTF8: TextEncoding
kUnion: ConvergeMode
kUnion_PathOp: PathOp
kUnknown: GrGLFormat
kUnknown_AlphaType: AlphaType
kUnknown_ColorType: ColorType
kUnknown_PixelGeometry: PixelGeometry
kUnpremul_AlphaType: AlphaType
kVertex_GrGLBackendState: GrGLBackendState
kView_GrGLBackendState: GrGLBackendState
kVulkan: GrBackendApi
kWBMP: EncodedImageFormat
kWEBP: EncodedImageFormat
kWinding: PathFillType
kXOR_PathOp: PathOp
kXor: ConvergeMode
kYes: Budgeted
kZero: BlendModeCoeff

class AlphaThresholdFilter:
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def Make(cls, region: Region, innerMin: float, outerMax: float, input: ImageFilter = ..., cropRect: ImageFilter.CropRect = ...) -> ImageFilter: ...

class AlphaType:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    kLastEnum_AlphaType: ClassVar[AlphaType] = ...
    kOpaque_AlphaType: ClassVar[AlphaType] = ...
    kPremul_AlphaType: ClassVar[AlphaType] = ...
    kUnknown_AlphaType: ClassVar[AlphaType] = ...
    kUnpremul_AlphaType: ClassVar[AlphaType] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class ApplyPerspectiveClip:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    kNo: ClassVar[ApplyPerspectiveClip] = ...
    kYes: ClassVar[ApplyPerspectiveClip] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class ArithmeticImageFilter:
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def Make(cls, k1: float, k2: float, k3: float, k4: float, enforcePMColor: bool, background: ImageFilter, foreground: ImageFilter = ..., cropRect: ImageFilter.CropRect = ...) -> ImageFilter: ...

class AutoCanvasRestore:
    def __init__(self, canvas: SkCanvas, doSave: bool = ...) -> None: ...
    def restore(self) -> None: ...
    def __enter__(self) -> None: ...
    def __exit__(self, *args) -> None: ...

class BBHFactory:
    def __init__(self, *args, **kwargs) -> None: ...

class BBoxHierarchy(RefCnt):
    class Metadata:
        isDraw: bool
        def __init__(self, *args, **kwargs) -> None: ...
    def __init__(self) -> None: ...
    def bytesUsed(self) -> int: ...
    @overload
    def insert(self, rects: Rect, N: int) -> None: ...
    @overload
    def insert(self, rects: Rect, metadata: BBoxHierarchy.Metadata, N: int) -> None: ...
    def search(self, query: Rect, results, std) -> None: ...

class BackingFit:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    kApprox: ClassVar[BackingFit] = ...
    kExact: ClassVar[BackingFit] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class Bitmap:
    class AllocFlags:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        kZeroPixels_AllocFlag: ClassVar[Bitmap.AllocFlags] = ...
        def __init__(self, value: int) -> None: ...
        def __and__(self, other: object) -> object: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> object: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: object) -> object: ...
        def __rand__(self, other: object) -> object: ...
        def __ror__(self, other: object) -> object: ...
        def __rxor__(self, other: object) -> object: ...
        def __setstate__(self, state: int) -> None: ...
        def __xor__(self, other: object) -> object: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    kZeroPixels_AllocFlag: ClassVar[Bitmap.AllocFlags] = ...
    def __init__(self, src: Bitmap = ...) -> None: ...
    def allocN32Pixels(self, width: int, height: int, isOpaque: bool) -> None: ...
    def allocPixels(self, info: SkImageInfo = ..., rowBytes: int = ...) -> None: ...
    def allocPixelsFlags(self, info: SkImageInfo, flags: int) -> None: ...
    def alphaType(self) -> SkAlphaType: ...
    def bounds(self) -> IRect: ...
    def bytesPerPixel(self) -> int: ...
    def colorSpace(self) -> ColorSpace: ...
    def colorType(self) -> SkColorType: ...
    def computeByteSize(self) -> int: ...
    def dimensions(self) -> ISize: ...
    def drawsNothing(self) -> bool: ...
    def empty(self) -> bool: ...
    def erase(self, c: int, area: IRect) -> None: ...
    def eraseARGB(self, a: int, r: int, g: int, b: int) -> None: ...
    def eraseColor(self, c: int) -> None: ...
    def extractAlpha(self, dst: Bitmap, paint: SkPaint = ..., offset: IPoint = ...) -> bool: ...
    def extractSubset(self, dst: Bitmap, subset: IRect) -> bool: ...
    def getAlphaf(self, x: int, y: int) -> float: ...
    def getBounds(self) -> IRect: ...
    def getColor(self, x: int, y: int) -> int: ...
    def getGenerationID(self) -> int: ...
    def getPixels(self) -> object: ...
    def getSubset(self) -> IRect: ...
    def height(self) -> int: ...
    def info(self) -> SkImageInfo: ...
    @overload
    def installPixels(self, info: SkImageInfo, pixels: object, rowBytes: int) -> bool: ...
    @overload
    def installPixels(self, pixmap: SkPixmap) -> bool: ...
    def isImmutable(self) -> bool: ...
    def isNull(self) -> bool: ...
    def isOpaque(self) -> bool: ...
    def makeShader(self, tmx: TileMode = ..., tmy: TileMode = ..., localMatrix: Matrix = ...) -> SkShader: ...
    def notifyPixelsChanged(self) -> None: ...
    def peekPixels(self, pixmap: SkPixmap) -> bool: ...
    def pixmap(self) -> SkPixmap: ...
    @overload
    def readPixels(self, dstInfo: SkImageInfo, dstPixels: buffer, dstRowBytes: int = ..., srcX: int = ..., srcY: int = ...) -> bool: ...
    @overload
    def readPixels(self, dst: SkPixmap, srcX: int = ..., srcY: int = ...) -> bool: ...
    def readyToDraw(self) -> bool: ...
    def refColorSpace(self) -> ColorSpace: ...
    def reset(self) -> None: ...
    def rowBytes(self) -> int: ...
    def rowBytesAsPixels(self) -> int: ...
    def setAlphaType(self, alphaType: SkAlphaType) -> bool: ...
    def setImmutable(self) -> None: ...
    def setInfo(self, imageInfo: SkImageInfo, rowBytes: int = ...) -> bool: ...
    def setPixels(self, pixels: buffer) -> None: ...
    def shiftPerPixel(self) -> int: ...
    def swap(self, other: Bitmap) -> None: ...
    def tobytes(self) -> object: ...
    def tryAllocN32Pixels(self, width: int, height: int, isOpaque: bool) -> bool: ...
    def tryAllocPixels(self, info: SkImageInfo = ..., rowBytes: int = ...) -> bool: ...
    def tryAllocPixelsFlags(self, info: SkImageInfo, flags: int) -> bool: ...
    def width(self) -> int: ...
    def writePixels(self, src: SkPixmap, dstX: int = ..., dstY: int = ...) -> bool: ...
    def __getitem__(self, arg0: object) -> int: ...
    def __len__(self) -> int: ...
    @property
    def __array_interface__(self) -> dict: ...

class BlendMode:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    kClear: ClassVar[BlendMode] = ...
    kColor: ClassVar[BlendMode] = ...
    kColorBurn: ClassVar[BlendMode] = ...
    kColorDodge: ClassVar[BlendMode] = ...
    kDarken: ClassVar[BlendMode] = ...
    kDifference: ClassVar[BlendMode] = ...
    kDst: ClassVar[BlendMode] = ...
    kDstATop: ClassVar[BlendMode] = ...
    kDstIn: ClassVar[BlendMode] = ...
    kDstOut: ClassVar[BlendMode] = ...
    kDstOver: ClassVar[BlendMode] = ...
    kExclusion: ClassVar[BlendMode] = ...
    kHardLight: ClassVar[BlendMode] = ...
    kHue: ClassVar[BlendMode] = ...
    kLastCoeffMode: ClassVar[BlendMode] = ...
    kLastMode: ClassVar[BlendMode] = ...
    kLastSeparableMode: ClassVar[BlendMode] = ...
    kLighten: ClassVar[BlendMode] = ...
    kLuminosity: ClassVar[BlendMode] = ...
    kModulate: ClassVar[BlendMode] = ...
    kMultiply: ClassVar[BlendMode] = ...
    kOverlay: ClassVar[BlendMode] = ...
    kPlus: ClassVar[BlendMode] = ...
    kSaturation: ClassVar[BlendMode] = ...
    kScreen: ClassVar[BlendMode] = ...
    kSoftLight: ClassVar[BlendMode] = ...
    kSrc: ClassVar[BlendMode] = ...
    kSrcATop: ClassVar[BlendMode] = ...
    kSrcIn: ClassVar[BlendMode] = ...
    kSrcOut: ClassVar[BlendMode] = ...
    kSrcOver: ClassVar[BlendMode] = ...
    kXor: ClassVar[BlendMode] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class BlendModeCoeff:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    kCoeffCount: ClassVar[BlendModeCoeff] = ...
    kDA: ClassVar[BlendModeCoeff] = ...
    kDC: ClassVar[BlendModeCoeff] = ...
    kIDA: ClassVar[BlendModeCoeff] = ...
    kIDC: ClassVar[BlendModeCoeff] = ...
    kISA: ClassVar[BlendModeCoeff] = ...
    kISC: ClassVar[BlendModeCoeff] = ...
    kOne: ClassVar[BlendModeCoeff] = ...
    kSA: ClassVar[BlendModeCoeff] = ...
    kSC: ClassVar[BlendModeCoeff] = ...
    kZero: ClassVar[BlendModeCoeff] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class BlurImageFilter:
    class TileMode:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        kClampToBlack_TileMode: ClassVar[BlurImageFilter.TileMode] = ...
        kClamp_TileMode: ClassVar[BlurImageFilter.TileMode] = ...
        kLast_TileMode: ClassVar[BlurImageFilter.TileMode] = ...
        kMax_TileMode: ClassVar[BlurImageFilter.TileMode] = ...
        kRepeat_TileMode: ClassVar[BlurImageFilter.TileMode] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    kClampToBlack_TileMode: ClassVar[BlurImageFilter.TileMode] = ...
    kClamp_TileMode: ClassVar[BlurImageFilter.TileMode] = ...
    kLast_TileMode: ClassVar[BlurImageFilter.TileMode] = ...
    kMax_TileMode: ClassVar[BlurImageFilter.TileMode] = ...
    kRepeat_TileMode: ClassVar[BlurImageFilter.TileMode] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def Make(cls, sigmaX: float, sigmaY: float, input: ImageFilter = ..., cropRect: ImageFilter.CropRect = ..., tileMode: BlurImageFilter.TileMode = ...) -> ImageFilter: ...

class BlurMaskFilter:
    def __init__(self, *args, **kwargs) -> None: ...

class BlurStyle:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    kInner_BlurStyle: ClassVar[BlurStyle] = ...
    kLastEnum_BlurStyle: ClassVar[BlurStyle] = ...
    kNormal_BlurStyle: ClassVar[BlurStyle] = ...
    kOuter_BlurStyle: ClassVar[BlurStyle] = ...
    kSolid_BlurStyle: ClassVar[BlurStyle] = ...
    def __init__(self, value: int) -> None: ...
    def __and__(self, other: object) -> object: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __invert__(self) -> object: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __or__(self, other: object) -> object: ...
    def __rand__(self, other: object) -> object: ...
    def __ror__(self, other: object) -> object: ...
    def __rxor__(self, other: object) -> object: ...
    def __setstate__(self, state: int) -> None: ...
    def __xor__(self, other: object) -> object: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class Budgeted:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    kNo: ClassVar[Budgeted] = ...
    kYes: ClassVar[Budgeted] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class Canvas:
    class Lattice:
        class RectType:
            __members__: ClassVar[dict] = ...  # read-only
            __entries: ClassVar[dict] = ...
            kDefault: ClassVar[Canvas.Lattice.RectType] = ...
            kFixedColor: ClassVar[Canvas.Lattice.RectType] = ...
            kTransparent: ClassVar[Canvas.Lattice.RectType] = ...
            def __init__(self, value: int) -> None: ...
            def __eq__(self, other: object) -> bool: ...
            def __getstate__(self) -> int: ...
            def __hash__(self) -> int: ...
            def __index__(self) -> int: ...
            def __int__(self) -> int: ...
            def __ne__(self, other: object) -> bool: ...
            def __setstate__(self, state: int) -> None: ...
            @property
            def name(self) -> str: ...
            @property
            def value(self) -> int: ...
        kDefault: ClassVar[Canvas.Lattice.RectType] = ...
        kFixedColor: ClassVar[Canvas.Lattice.RectType] = ...
        kTransparent: ClassVar[Canvas.Lattice.RectType] = ...
        fBounds: IRect
        fColors: int
        fRectTypes: Canvas.Lattice.RectType
        fXCount: int
        fXDivs: int
        fYCount: int
        fYDivs: int
        def __init__(self, *args, **kwargs) -> None: ...

    class PointMode:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        kLines_PointMode: ClassVar[Canvas.PointMode] = ...
        kPoints_PointMode: ClassVar[Canvas.PointMode] = ...
        kPolygon_PointMode: ClassVar[Canvas.PointMode] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class QuadAAFlags:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        kAll_QuadAAFlags: ClassVar[Canvas.QuadAAFlags] = ...
        kBottom_QuadAAFlag: ClassVar[Canvas.QuadAAFlags] = ...
        kLeft_QuadAAFlag: ClassVar[Canvas.QuadAAFlags] = ...
        kNone_QuadAAFlags: ClassVar[Canvas.QuadAAFlags] = ...
        kRight_QuadAAFlag: ClassVar[Canvas.QuadAAFlags] = ...
        kTop_QuadAAFlag: ClassVar[Canvas.QuadAAFlags] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class SaveLayerFlags:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        kF16ColorType: ClassVar[Canvas.SaveLayerFlags] = ...
        kInitWithPrevious_SaveLayerFlag: ClassVar[Canvas.SaveLayerFlags] = ...
        kMaskAgainstCoverage_EXPERIMENTAL_DONT_USE_SaveLayerFlag: ClassVar[Canvas.SaveLayerFlags] = ...
        kPreserveLCDText_SaveLayerFlag: ClassVar[Canvas.SaveLayerFlags] = ...
        def __init__(self, value: int) -> None: ...
        def __and__(self, other: object) -> object: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> object: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: object) -> object: ...
        def __rand__(self, other: object) -> object: ...
        def __ror__(self, other: object) -> object: ...
        def __rxor__(self, other: object) -> object: ...
        def __setstate__(self, state: int) -> None: ...
        def __xor__(self, other: object) -> object: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class SaveLayerRec:
        fBackdrop: Any
        fBounds: Rect
        fPaint: Paint
        fSaveLayerFlags: int
        @overload
        def __init__(self) -> None: ...
        @overload
        def __init__(self, bounds: Rect, paint: Paint, saveLayerFlags: int = ...) -> None: ...
        @overload
        def __init__(self, bounds: Rect, paint: Paint, backdrop: ImageFilter, saveLayerFlags: int) -> None: ...

    class SrcRectConstraint:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        kFast_SrcRectConstraint: ClassVar[Canvas.SrcRectConstraint] = ...
        kStrict_SrcRectConstraint: ClassVar[Canvas.SrcRectConstraint] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    kAll_QuadAAFlags: ClassVar[Canvas.QuadAAFlags] = ...
    kBottom_QuadAAFlag: ClassVar[Canvas.QuadAAFlags] = ...
    kF16ColorType: ClassVar[Canvas.SaveLayerFlags] = ...
    kFast_SrcRectConstraint: ClassVar[Canvas.SrcRectConstraint] = ...
    kInitWithPrevious_SaveLayerFlag: ClassVar[Canvas.SaveLayerFlags] = ...
    kLeft_QuadAAFlag: ClassVar[Canvas.QuadAAFlags] = ...
    kLines_PointMode: ClassVar[Canvas.PointMode] = ...
    kMaskAgainstCoverage_EXPERIMENTAL_DONT_USE_SaveLayerFlag: ClassVar[Canvas.SaveLayerFlags] = ...
    kNone_QuadAAFlags: ClassVar[Canvas.QuadAAFlags] = ...
    kPoints_PointMode: ClassVar[Canvas.PointMode] = ...
    kPolygon_PointMode: ClassVar[Canvas.PointMode] = ...
    kPreserveLCDText_SaveLayerFlag: ClassVar[Canvas.SaveLayerFlags] = ...
    kRight_QuadAAFlag: ClassVar[Canvas.QuadAAFlags] = ...
    kStrict_SrcRectConstraint: ClassVar[Canvas.SrcRectConstraint] = ...
    kTop_QuadAAFlag: ClassVar[Canvas.QuadAAFlags] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, array: numpy.ndarray, colorType: ColorType = ..., alphaType: AlphaType = ..., colorSpace: ColorSpace = ..., surfaceProps: SkSurfaceProps = ...) -> None: ...
    @overload
    def __init__(self, width: int, height: int, props: SkSurfaceProps = ...) -> None: ...
    @overload
    def __init__(self, bitmap: Bitmap) -> None: ...
    @overload
    def __init__(self, bitmap: Bitmap, props: SkSurfaceProps) -> None: ...
    @classmethod
    def MakeRasterDirect(cls, imageInfo: ImageInfo, pixels: buffer, rowBytes: int = ..., surfaceProps: SkSurfaceProps = ...) -> Canvas: ...
    @classmethod
    def MakeRasterDirectN32(cls, width: int, height: int, pixels: buffer, rowBytes: int = ...) -> Canvas: ...
    def accessTopLayerPixels(self, origin: IPoint = ...) -> object: ...
    def androidFramework_setDeviceClipRestriction(self, rect: IRect) -> None: ...
    @overload
    def clear(self, color: int) -> None: ...
    @overload
    def clear(self, color: Color4f) -> None: ...
    @overload
    def clipPath(self, path: Path, op: ClipOp, doAntiAlias: bool) -> None: ...
    @overload
    def clipPath(self, path: Path, op: ClipOp) -> None: ...
    @overload
    def clipPath(self, path: Path, doAntiAlias: bool = ...) -> None: ...
    @overload
    def clipRRect(self, rrect: RRect, op: ClipOp, doAntiAlias: bool) -> None: ...
    @overload
    def clipRRect(self, rrect: RRect, op: ClipOp) -> None: ...
    @overload
    def clipRRect(self, rrect: RRect, doAntiAlias: bool = ...) -> None: ...
    @overload
    def clipRect(self, rect: Rect, op: ClipOp, doAntiAlias: bool) -> None: ...
    @overload
    def clipRect(self, rect: Rect, op: ClipOp) -> None: ...
    @overload
    def clipRect(self, rect: Rect, doAntiAlias: bool = ...) -> None: ...
    def clipRegion(self, deviceRgn: Region, op: ClipOp = ...) -> None: ...
    @overload
    def concat(self, matrix: Matrix) -> None: ...
    @overload
    def concat(self, m44: M44) -> None: ...
    def discard(self) -> None: ...
    def drawAnnotation(self, rect: Rect, key: str, value: Data) -> None: ...
    def drawArc(self, oval: Rect, startAngle: float, sweepAngle: float, useCenter: bool, paint: Paint) -> None: ...
    def drawAtlas(self, atlas: Image, xform: List[RSXform], tex: List[Rect], colors: List[int], mode: BlendMode, cullRect: Rect = ..., paint: Paint = ...) -> None: ...
    def drawBitmap(self, bitmap: Bitmap, left: float, top: float, paint: Paint = ...) -> None: ...
    @overload
    def drawBitmapRect(self, bitmap: Bitmap, src: Rect, dst: Rect, paint: Paint = ..., constraint: Canvas.SrcRectConstraint = ...) -> None: ...
    @overload
    def drawBitmapRect(self, bitmap: Bitmap, isrc: IRect, dst: Rect, paint: Paint = ..., constraint: Canvas.SrcRectConstraint = ...) -> None: ...
    @overload
    def drawBitmapRect(self, bitmap: Bitmap, dst: Rect, paint: Paint = ..., constraint: Canvas.SrcRectConstraint = ...) -> None: ...
    @overload
    def drawCircle(self, cx: float, cy: float, radius: float, paint: Paint) -> None: ...
    @overload
    def drawCircle(self, center: Point, radius: float, paint: Paint) -> None: ...
    @overload
    def drawColor(self, color: int, mode: BlendMode = ...) -> None: ...
    @overload
    def drawColor(self, color: Color4f, mode: BlendMode = ...) -> None: ...
    def drawDRRect(self, outer: RRect, inner: RRect, paint: Paint) -> None: ...
    def drawIRect(self, rect: IRect, paint: Paint) -> None: ...
    def drawImage(self, image: Image, left: float, top: float, paint: Paint = ...) -> None: ...
    def drawImageNine(self, image: Image, center: IRect, dst: Rect, paint: Paint = ...) -> None: ...
    @overload
    def drawImageRect(self, image: Image, src: Rect, dst: Rect, paint: Paint = ..., constraint: Canvas.SrcRectConstraint = ...) -> None: ...
    @overload
    def drawImageRect(self, image: Image, isrc: IRect, dst: Rect, paint: Paint = ..., constraint: Canvas.SrcRectConstraint = ...) -> None: ...
    @overload
    def drawImageRect(self, image: Image, dst: Rect, paint: Paint = ...) -> None: ...
    @overload
    def drawLine(self, x0: float, y0: float, x1: float, y1`: float, paint: Paint) -> None: ...
    @overload
    def drawLine(self, p0: Point, p1: Point, paint: Paint) -> None: ...
    def drawOval(self, oval: Rect, paint: Paint) -> None: ...
    def drawPaint(self, paint: Paint) -> None: ...
    def drawPatch(self, cubics: List[Point], colors: List[int], texCoords: List[Point], mode: BlendMode, paint: Paint) -> None: ...
    def drawPath(self, path: Path, paint: Paint) -> None: ...
    @overload
    def drawPicture(self, picture: Picture, matrix: Matrix = ..., paint: Paint = ...) -> None: ...
    @overload
    def drawPicture(self) -> Any: ...
    @overload
    def drawPicture(self) -> Any: ...
    @overload
    def drawPoint(self, x: float, y: float, paint: Paint) -> None: ...
    @overload
    def drawPoint(self, p: Point, paint: Paint) -> None: ...
    def drawPoints(self, mode: Canvas.PointMode, pts: List[Point], paint: Paint) -> None: ...
    def drawRRect(self, rrect: RRect, paint: Paint) -> None: ...
    def drawRect(self, rect: Rect, paint: Paint) -> None: ...
    def drawRegion(self, region: Region, paint: Paint) -> None: ...
    def drawRoundRect(self, rect: Rect, rx: float, ry: float, paint: Paint) -> None: ...
    def drawSimpleText(self, text: str, x: float, y: float, font: Font, paint: Paint) -> None: ...
    def drawString(self, text: str, x: float, y: float, font: Font, paint: Paint) -> None: ...
    def drawTextBlob(self, blob: TextBlob, x: float, y: float, paint: Paint) -> None: ...
    def drawVertices(self, vertices: Vertices, paint: Paint, mode: BlendMode = ...) -> None: ...
    def flush(self) -> None: ...
    def getBaseLayerSize(self) -> ISize: ...
    @overload
    def getDeviceClipBounds(self) -> IRect: ...
    @overload
    def getDeviceClipBounds(self, bounds: IRect) -> bool: ...
    @overload
    def getLocalClipBounds(self) -> Rect: ...
    @overload
    def getLocalClipBounds(self, bounds: Rect) -> bool: ...
    def getLocalToDevice(self) -> M44: ...
    def getProps(self, props: SkSurfaceProps) -> bool: ...
    def getSaveCount(self) -> int: ...
    @overload
    def getSurface(self) -> SkSurface: ...
    @overload
    def getSurface(self) -> Any: ...
    def getTotalMatrix(self) -> Matrix: ...
    def imageInfo(self) -> ImageInfo: ...
    def isClipEmpty(self) -> bool: ...
    def isClipRect(self) -> bool: ...
    def makeSurface(self, info: ImageInfo, props: SkSurfaceProps = ...) -> SkSurface: ...
    def peekPixels(self, pixmap: Pixmap) -> bool: ...
    @overload
    def quickReject(self, rect: Rect) -> bool: ...
    @overload
    def quickReject(self, path: Path) -> bool: ...
    @overload
    def readPixels(self, dstInfo: ImageInfo, dstPixels: buffer, dstRowBytes: int = ..., srcX: int = ..., srcY: int = ...) -> bool: ...
    @overload
    def readPixels(self, pixmap: Pixmap, srcX: int = ..., srcY: int = ...) -> bool: ...
    @overload
    def readPixels(self, bitmap: Bitmap, srcX: int = ..., srcY: int = ...) -> bool: ...
    def resetMatrix(self) -> None: ...
    def restore(self) -> None: ...
    def restoreToCount(self, saveCount: int) -> None: ...
    @overload
    def rotate(self, degrees: float) -> None: ...
    @overload
    def rotate(self, degrees: float, px: float, py: float) -> None: ...
    def save(self) -> int: ...
    @overload
    def saveLayer(self, bounds: Rect = ..., paint: Paint = ...) -> int: ...
    @overload
    def saveLayer(self, layerRec: Canvas.SaveLayerRec) -> int: ...
    def saveLayerAlpha(self, bounds: Rect, alpha: int) -> int: ...
    def scale(self, sx: float, sy: float) -> None: ...
    def setMatrix(self, matrix: Matrix) -> None: ...
    def skew(self, sx: float, sy: float) -> None: ...
    def toarray(self, srcX: int = ..., srcY: int = ..., colorType: ColorType = ..., alphaType: AlphaType = ..., colorSpace: ColorSpace = ...) -> numpy.ndarray: ...
    def translate(self, dx: float, dy: float) -> None: ...
    @overload
    def writePixels(self, info: ImageInfo, pixels: buffer, rowBytes: int = ..., x: int = ..., y: int = ...) -> bool: ...
    @overload
    def writePixels(self, bitmap: Bitmap, x: int = ..., y: int = ...) -> bool: ...

class ClipOp:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    kDifference: ClassVar[ClipOp] = ...
    kIntersect: ClassVar[ClipOp] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class Codec:
    class DisposalMethod:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        kKeep: ClassVar[Codec.DisposalMethod] = ...
        kRestoreBGColor: ClassVar[Codec.DisposalMethod] = ...
        kRestorePrevious: ClassVar[Codec.DisposalMethod] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class FrameInfo:
        fAlphaType: SkAlphaType
        fDisposalMethod: Any
        fDuration: int
        fFullyReceived: bool
        fRequiredFrame: int
        def __init__(self) -> None: ...

    class Options:
        fFrameIndex: int
        fPriorFrame: int
        fSubset: IRect
        fZeroInitialized: Codec.ZeroInitialized
        def __init__(self) -> None: ...

    class Result:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        kCouldNotRewind: ClassVar[Codec.Result] = ...
        kErrorInInput: ClassVar[Codec.Result] = ...
        kIncompleteInput: ClassVar[Codec.Result] = ...
        kInternalError: ClassVar[Codec.Result] = ...
        kInvalidConversion: ClassVar[Codec.Result] = ...
        kInvalidInput: ClassVar[Codec.Result] = ...
        kInvalidParameters: ClassVar[Codec.Result] = ...
        kInvalidScale: ClassVar[Codec.Result] = ...
        kSuccess: ClassVar[Codec.Result] = ...
        kUnimplemented: ClassVar[Codec.Result] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class ScanlineOrder:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        kKeep: ClassVar[Codec.ScanlineOrder] = ...
        kRestoreBGColor: ClassVar[Codec.ScanlineOrder] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class SelectionPolicy:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        kPreferAnimation: ClassVar[Codec.SelectionPolicy] = ...
        kPreferStillImage: ClassVar[Codec.SelectionPolicy] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class ZeroInitialized:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        kNo_ZeroInitialized: ClassVar[Codec.ZeroInitialized] = ...
        kYes_ZeroInitialized: ClassVar[Codec.ZeroInitialized] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    kNoFrame: ClassVar[int] = ...  # read-only
    kRepetitionCountInfinite: ClassVar[int] = ...  # read-only
    kCouldNotRewind: ClassVar[Codec.Result] = ...
    kErrorInInput: ClassVar[Codec.Result] = ...
    kIncompleteInput: ClassVar[Codec.Result] = ...
    kInternalError: ClassVar[Codec.Result] = ...
    kInvalidConversion: ClassVar[Codec.Result] = ...
    kInvalidInput: ClassVar[Codec.Result] = ...
    kInvalidParameters: ClassVar[Codec.Result] = ...
    kInvalidScale: ClassVar[Codec.Result] = ...
    kKeep: ClassVar[Codec.DisposalMethod] = ...
    kNo_ZeroInitialized: ClassVar[Codec.ZeroInitialized] = ...
    kPreferAnimation: ClassVar[Codec.SelectionPolicy] = ...
    kPreferStillImage: ClassVar[Codec.SelectionPolicy] = ...
    kRestoreBGColor: ClassVar[Codec.DisposalMethod] = ...
    kRestorePrevious: ClassVar[Codec.DisposalMethod] = ...
    kSuccess: ClassVar[Codec.Result] = ...
    kUnimplemented: ClassVar[Codec.Result] = ...
    kYes_ZeroInitialized: ClassVar[Codec.ZeroInitialized] = ...
    def __init__(self, data: buffer) -> None: ...
    @classmethod
    def MakeFromData(cls, data: buffer) -> Codec: ...
    @classmethod
    def MinBufferedBytesNeeded(cls) -> int: ...
    @classmethod
    def ResultToString(cls, result: Codec.Result) -> str: ...
    def bounds(self) -> IRect: ...
    def dimensions(self) -> ISize: ...
    def getEncodedFormat(self) -> SkEncodedImageFormat: ...
    def getFrameCount(self) -> int: ...
    @overload
    def getFrameInfo(self, index: int, info: Codec.FrameInfo) -> bool: ...
    @overload
    def getFrameInfo(self) -> List[Codec.FrameInfo]: ...
    def getInfo(self) -> SkImageInfo: ...
    def getOrigin(self) -> EncodedOrigin: ...
    @overload
    def getPixels(self, info: SkImageInfo, data: buffer, rowBytes: int, options: Codec.Options = ...) -> Codec.Result: ...
    @overload
    def getPixels(self, pixmap: SkPixmap, options: Codec.Options = ...) -> Codec.Result: ...
    def getRepetitionCount(self, *args, **kwargs) -> Any: ...
    def getScaledDimensions(self, desiredScale: float) -> ISize: ...
    def getScanlineOrder(self) -> Codec.ScanlineOrder: ...
    def getScanlines(self, dst: buffer, countLines: int, rowBytes: int) -> int: ...
    def getValidSubset(self, desiredSubset: IRect) -> bool: ...
    def getYUVAPlanes(self, yuvaPixmaps: SkYUVAPixmaps) -> Codec.Result: ...
    def incrementalDecode(self, rowsDecoded: int = ...) -> Codec.Result: ...
    def nextScanline(self) -> int: ...
    def outputScanline(self, inputScanline: int) -> int: ...
    def queryYUVAInfo(self, supportedDataTypes) -> object: ...
    def skipScanlines(self, countLines: int) -> bool: ...
    def startIncrementalDecode(self, dstInfo: SkImageInfo, dst: buffer, rowBytes: int, options: Codec.Options = ...) -> Codec.Result: ...
    def startScanlineDecode(self, dstInfo: SkImageInfo, options: Codec.Options = ...) -> Codec.Result: ...

class Color4f:
    kBlack: ClassVar[Color4f] = ...  # read-only
    kBlue: ClassVar[Color4f] = ...  # read-only
    kCyan: ClassVar[Color4f] = ...  # read-only
    kDkGray: ClassVar[Color4f] = ...  # read-only
    kGray: ClassVar[Color4f] = ...  # read-only
    kGreen: ClassVar[Color4f] = ...  # read-only
    kLtGray: ClassVar[Color4f] = ...  # read-only
    kMagenta: ClassVar[Color4f] = ...  # read-only
    kRed: ClassVar[Color4f] = ...  # read-only
    kTransparent: ClassVar[Color4f] = ...  # read-only
    kWhite: ClassVar[Color4f] = ...  # read-only
    kYellow: ClassVar[Color4f] = ...  # read-only
    __hash__: ClassVar[None] = ...
    fA: float
    fB: float
    fG: float
    fR: float
    @overload
    def __init__(self, color: int) -> None: ...
    @overload
    def __init__(self, red: float, green: float, blue: float, alpha: float = ...) -> None: ...
    @overload
    def __init__(self, t: tuple) -> None: ...
    @classmethod
    def FromBytes_RGBA(cls, rgba: int) -> Color4f: ...
    @classmethod
    def FromColor(cls, color: int) -> Color4f: ...
    def fitsInBytes(self) -> bool: ...
    def isOpaque(self) -> bool: ...
    def makeOpaque(self) -> Color4f: ...
    def toBytes_RGBA(self) -> int: ...
    def toColor(self) -> int: ...
    def vec(self) -> memoryview: ...
    def __eq__(self, other: Color4f) -> bool: ...
    def __getitem__(self, index: int) -> float: ...
    def __int__(self) -> int: ...
    def __len__(self) -> int: ...
    @overload
    def __mul__(self, arg0: float) -> Color4f: ...
    @overload
    def __mul__(self, arg0: Color4f) -> Color4f: ...
    def __ne__(self, other: Color4f) -> bool: ...
    def __setitem__(self, index: int, value: float) -> None: ...

class ColorChannel:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    kA: ClassVar[ColorChannel] = ...
    kB: ClassVar[ColorChannel] = ...
    kG: ClassVar[ColorChannel] = ...
    kLastEnum: ClassVar[ColorChannel] = ...
    kR: ClassVar[ColorChannel] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class ColorChannelFlag:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    kAlpha_ColorChannelFlag: ClassVar[ColorChannelFlag] = ...
    kBlue_ColorChannelFlag: ClassVar[ColorChannelFlag] = ...
    kGray_ColorChannelFlag: ClassVar[ColorChannelFlag] = ...
    kGreen_ColorChannelFlag: ClassVar[ColorChannelFlag] = ...
    kRGBA_ColorChannelFlags: ClassVar[ColorChannelFlag] = ...
    kRGB_ColorChannelFlags: ClassVar[ColorChannelFlag] = ...
    kRG_ColorChannelFlags: ClassVar[ColorChannelFlag] = ...
    kRed_ColorChannelFlag: ClassVar[ColorChannelFlag] = ...
    def __init__(self, value: int) -> None: ...
    def __and__(self, other: object) -> object: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __invert__(self) -> object: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __or__(self, other: object) -> object: ...
    def __rand__(self, other: object) -> object: ...
    def __ror__(self, other: object) -> object: ...
    def __rxor__(self, other: object) -> object: ...
    def __setstate__(self, state: int) -> None: ...
    def __xor__(self, other: object) -> object: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class ColorFilter(Flattanable):
    class Flags:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        kAlphaUnchanged_Flag: ClassVar[ColorFilter.Flags] = ...
        def __init__(self, value: int) -> None: ...
        def __and__(self, other: object) -> object: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> object: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: object) -> object: ...
        def __rand__(self, other: object) -> object: ...
        def __ror__(self, other: object) -> object: ...
        def __rxor__(self, other: object) -> object: ...
        def __setstate__(self, state: int) -> None: ...
        def __xor__(self, other: object) -> object: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    kAlphaUnchanged_Flag: ClassVar[ColorFilter.Flags] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def Deserialize(cls, data: buffer) -> ColorFilter: ...
    def asAColorMatrix(self) -> object: ...
    def asAColorMode(self) -> object: ...
    def asColorMode(self) -> object: ...
    def filterColor(self, color: int) -> int: ...
    def filterColor4f(self, srcColor: Color4f, srcCS: ColorSpace, dstCS: ColorSpace) -> Color4f: ...
    def getFlags(self) -> int: ...
    def makeComposed(self, inner: ColorFilter) -> ColorFilter: ...

class ColorFilterImageFilter:
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def Make(cls, cf: ColorFilter, input: ImageFilter = ..., cropRect: ImageFilter.CropRect = ...) -> ImageFilter: ...

class ColorFilters:
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def Blend(cls, c: int, mode: BlendMode) -> ColorFilter: ...
    @classmethod
    def Compose(cls, outer: ColorFilter, inner: ColorFilter) -> ColorFilter: ...
    @overload
    @classmethod
    def HSLAMatrix(cls, rowMajor: List[float]) -> ColorFilter: ...
    @overload
    @classmethod
    def HSLAMatrix(cls, colorMatrix: ColorMatrix) -> ColorFilter: ...
    @classmethod
    def Lerp(cls, t: float, dst: ColorFilter, src: ColorFilter) -> ColorFilter: ...
    @classmethod
    def LinearToSRGBGamma(cls) -> ColorFilter: ...
    @classmethod
    def Matrix(cls, rowMajor: List[float]) -> ColorFilter: ...
    @classmethod
    def SRGBToLinearGamma(cls) -> ColorFilter: ...

class ColorInfo:
    __hash__: ClassVar[None] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, ct: ColorType, at: AlphaType, cs: ColorSpace = ...) -> None: ...
    @overload
    def __init__(self, arg0: ColorInfo) -> None: ...
    def alphaType(self) -> AlphaType: ...
    def bytesPerPixel(self) -> int: ...
    def colorSpace(self) -> ColorSpace: ...
    def colorType(self) -> ColorType: ...
    def gammaCloseToSRGB(self) -> bool: ...
    def isOpaque(self) -> bool: ...
    def makeAlphaType(self, newAlphaType: AlphaType) -> ColorInfo: ...
    def makeColorSpace(self, cs: ColorSpace) -> ColorInfo: ...
    def makeColorType(self, newColorType: ColorType) -> ColorInfo: ...
    def refColorSpace(self) -> ColorSpace: ...
    def shiftPerPixel(self) -> int: ...
    def __eq__(self, arg0: ColorInfo) -> bool: ...
    def __ne__(self, arg0: ColorInfo) -> bool: ...

class ColorMatrix:
    def __init__(self) -> None: ...

class ColorMatrixFilter(ColorFilter):
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def MakeLightingFilter(cls, mul: int, add: int) -> ColorFilter: ...

class ColorSpace:
    __hash__: ClassVar[None] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def Deserialize(cls, data: capsule, length: int) -> ColorSpace: ...
    def Equals(self: ColorSpace, other: ColorSpace) -> bool: ...
    @classmethod
    def Make(cls, profile: cms.ICCProfile) -> ColorSpace: ...
    @classmethod
    def MakeRGB(cls, transferFn: cms.TransferFunction, toXYZ: cms.Matrix3x3) -> ColorSpace: ...
    @classmethod
    def MakeSRGB(cls) -> ColorSpace: ...
    @classmethod
    def MakeSRGBLinear(cls) -> ColorSpace: ...
    def deref(self) -> None: ...
    def gammaCloseToSRGB(self) -> bool: ...
    def gammaIsLinear(self) -> bool: ...
    def gamutTransformTo(self, dst: ColorSpace, src_to_dst: cms.Matrix3x3) -> None: ...
    def hash(self) -> int: ...
    def invTransferFn(self, fn: cms.TransferFunction) -> None: ...
    def isNumericalTransferFn(self, fn: cms.TransferFunction) -> bool: ...
    def isSRGB(self) -> bool: ...
    def makeColorSpin(self) -> ColorSpace: ...
    def makeLinearGamma(self) -> ColorSpace: ...
    def makeSRGBGamma(self) -> ColorSpace: ...
    def ref(self) -> None: ...
    def refCntGreaterThan(self, count: int) -> bool: ...
    def serialize(self) -> SkData: ...
    def toProfile(self) -> cms.ICCProfile: ...
    def toXYZD50(self, matrix: cms.Matrix3x3) -> bool: ...
    def toXYZD50Hash(self) -> int: ...
    @overload
    def transferFn(self, gabcdef: float) -> None: ...
    @overload
    def transferFn(self, fn: cms.TransferFunction) -> None: ...
    def transferFnHash(self) -> int: ...
    def unique(self) -> bool: ...
    def unref(self) -> None: ...
    def writeToMemory(self, memory: capsule) -> int: ...
    def __eq__(self, arg0: ColorSpace) -> bool: ...

class ColorType:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    kA16_float_ColorType: ClassVar[ColorType] = ...
    kA16_unorm_ColorType: ClassVar[ColorType] = ...
    kARGB_4444_ColorType: ClassVar[ColorType] = ...
    kAlpha_8_ColorType: ClassVar[ColorType] = ...
    kBGRA_1010102_ColorType: ClassVar[ColorType] = ...
    kBGRA_8888_ColorType: ClassVar[ColorType] = ...
    kBGR_101010x_ColorType: ClassVar[ColorType] = ...
    kGray_8_ColorType: ClassVar[ColorType] = ...
    kN32_ColorType: ClassVar[ColorType] = ...
    kR16G16B16A16_unorm_ColorType: ClassVar[ColorType] = ...
    kR16G16_float_ColorType: ClassVar[ColorType] = ...
    kR16G16_unorm_ColorType: ClassVar[ColorType] = ...
    kR8G8_unorm_ColorType: ClassVar[ColorType] = ...
    kRGBA_1010102_ColorType: ClassVar[ColorType] = ...
    kRGBA_8888_ColorType: ClassVar[ColorType] = ...
    kRGBA_F16Norm_ColorType: ClassVar[ColorType] = ...
    kRGBA_F16_ColorType: ClassVar[ColorType] = ...
    kRGBA_F32_ColorType: ClassVar[ColorType] = ...
    kRGB_101010x_ColorType: ClassVar[ColorType] = ...
    kRGB_565_ColorType: ClassVar[ColorType] = ...
    kRGB_888x_ColorType: ClassVar[ColorType] = ...
    kUnknown_ColorType: ClassVar[ColorType] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class ConvergeMode:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    kDifference: ClassVar[ConvergeMode] = ...
    kIntersect: ClassVar[ConvergeMode] = ...
    kLast: ClassVar[ConvergeMode] = ...
    kReverseDifference: ClassVar[ConvergeMode] = ...
    kUnion: ClassVar[ConvergeMode] = ...
    kXor: ClassVar[ConvergeMode] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class CornerPathEffect(PathEffect):
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def Make(cls, radius: float) -> PathEffect: ...

class DashPathEffect:
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def Make(cls, intervals: List[float], phase: float) -> PathEffect: ...

class Data:
    __hash__: ClassVar[None] = ...
    def __init__(self, buf: buffer, copy: bool = ...) -> None: ...
    @classmethod
    def MakeEmpty(cls) -> Data: ...
    @classmethod
    def MakeFromFileName(cls, path: str) -> Data: ...
    @classmethod
    def MakeSubset(cls, src: Data, offset: int, length: int) -> Data: ...
    @classmethod
    def MakeUninitialized(cls, length: int) -> Data: ...
    @classmethod
    def MakeWithCopy(cls, data: buffer) -> Data: ...
    @classmethod
    def MakeWithoutCopy(cls, data: buffer) -> Data: ...
    def bytes(self) -> bytes: ...
    def copyRange(self, offset: int, length: int, buffer: object) -> int: ...
    def data(self) -> memoryview: ...
    def deref(self) -> None: ...
    def equals(self, other: Data) -> bool: ...
    def isEmpty(self) -> bool: ...
    def ref(self) -> None: ...
    def refCntGreaterThan(self, count: int) -> bool: ...
    def size(self) -> int: ...
    def unique(self) -> bool: ...
    def unref(self) -> None: ...
    def writable_data(self) -> memoryview: ...
    def __eq__(self, other: Data) -> bool: ...

class DilateImageFilter:
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def Make(cls, radiusX: float, radiusY: float, input: ImageFilter = ..., cropRect: ImageFilter.CropRect = ...) -> ImageFilter: ...

class DiscretePathEffect(PathEffect):
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def Make(cls, segLength: float, dev: float, seedAssist: int = ...) -> PathEffect: ...

class DisplacementMapEffect:
    class ChannelSelectorType:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        kA_ChannelSelectorType: ClassVar[DisplacementMapEffect.ChannelSelectorType] = ...
        kB_ChannelSelectorType: ClassVar[DisplacementMapEffect.ChannelSelectorType] = ...
        kG_ChannelSelectorType: ClassVar[DisplacementMapEffect.ChannelSelectorType] = ...
        kLast_ChannelSelectorType: ClassVar[DisplacementMapEffect.ChannelSelectorType] = ...
        kR_ChannelSelectorType: ClassVar[DisplacementMapEffect.ChannelSelectorType] = ...
        kUnknown_ChannelSelectorType: ClassVar[DisplacementMapEffect.ChannelSelectorType] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    kA_ChannelSelectorType: ClassVar[DisplacementMapEffect.ChannelSelectorType] = ...
    kB_ChannelSelectorType: ClassVar[DisplacementMapEffect.ChannelSelectorType] = ...
    kG_ChannelSelectorType: ClassVar[DisplacementMapEffect.ChannelSelectorType] = ...
    kLast_ChannelSelectorType: ClassVar[DisplacementMapEffect.ChannelSelectorType] = ...
    kR_ChannelSelectorType: ClassVar[DisplacementMapEffect.ChannelSelectorType] = ...
    kUnknown_ChannelSelectorType: ClassVar[DisplacementMapEffect.ChannelSelectorType] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @overload
    @classmethod
    def Make(cls, xChannelSelector: DisplacementMapEffect.ChannelSelectorType, yChannelSelector: DisplacementMapEffect.ChannelSelectorType, scale: float, displacement: ImageFilter, color: ImageFilter, cropRect: ImageFilter.CropRect = ...) -> ImageFilter: ...
    @overload
    @classmethod
    def Make(cls, xChannelSelector: ColorChannel, yChannelSelector: ColorChannel, scale: float, displacement: ImageFilter, color: ImageFilter, cropRect: ImageFilter.CropRect = ...) -> ImageFilter: ...

class Document(RefCnt):
    def __init__(self, *args, **kwargs) -> None: ...
    def abort(self) -> None: ...
    def beginPage(self, width: float, height: float, content: Rect = ...) -> SkCanvas: ...
    def close(self) -> None: ...
    def endPage(self) -> None: ...
    def page(self, *args, **kwargs) -> Any: ...
    def __enter__(self) -> Document: ...
    def __exit__(self, arg0: object, arg1: object, arg2: object) -> None: ...

class Drawable(Flattanable):
    def __init__(self, *args, **kwargs) -> None: ...
    def draw(self, canvas: SkCanvas, matrix: Matrix = ...) -> None: ...
    def getBounds(self) -> Rect: ...
    def getGenerationID(self) -> int: ...
    def newPictureSnapshot(self) -> Picture: ...
    def notifyDrawingChanged(self) -> None: ...

class DropShadowImageFilter:
    class ShadowMode:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        kDrawShadowAndForeground_ShadowMode: ClassVar[DropShadowImageFilter.ShadowMode] = ...
        kDrawShadowOnly_ShadowMode: ClassVar[DropShadowImageFilter.ShadowMode] = ...
        kLast_ShadowMode: ClassVar[DropShadowImageFilter.ShadowMode] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    kShadowModeCount: ClassVar[int] = ...  # read-only
    kDrawShadowAndForeground_ShadowMode: ClassVar[DropShadowImageFilter.ShadowMode] = ...
    kDrawShadowOnly_ShadowMode: ClassVar[DropShadowImageFilter.ShadowMode] = ...
    kLast_ShadowMode: ClassVar[DropShadowImageFilter.ShadowMode] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def Make(cls, dx: float, dy: float, sigmaX: float, sigmaY: float, color: int, shadowMode: DropShadowImageFilter.ShadowMode, input: ImageFilter = ..., cropRect: ImageFilter.CropRect = ...) -> ImageFilter: ...

class DynamicMemoryWStream(WStream):
    def __init__(self) -> None: ...
    def copyTo(self, dst: buffer) -> None: ...
    def copyToAndReset(self, dst: buffer) -> None: ...
    def detachAsData(self) -> Data: ...
    def detachAsStream(self) -> StreamAsset: ...
    def padToAlign4(self) -> None: ...
    def prependToAndReset(self, dst: DynamicMemoryWStream) -> None: ...
    def read(self, data: buffer, offset: int = ...) -> bool: ...
    def reset(self) -> None: ...
    @overload
    def writeToAndReset(self, dst: WStream) -> bool: ...
    @overload
    def writeToAndReset(self, dst: DynamicMemoryWStream) -> bool: ...
    def writeToStream(self, dst: WStream) -> bool: ...

class EncodedImageFormat:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    kASTC: ClassVar[EncodedImageFormat] = ...
    kBMP: ClassVar[EncodedImageFormat] = ...
    kDNG: ClassVar[EncodedImageFormat] = ...
    kGIF: ClassVar[EncodedImageFormat] = ...
    kHEIF: ClassVar[EncodedImageFormat] = ...
    kICO: ClassVar[EncodedImageFormat] = ...
    kJPEG: ClassVar[EncodedImageFormat] = ...
    kKTX: ClassVar[EncodedImageFormat] = ...
    kPKM: ClassVar[EncodedImageFormat] = ...
    kPNG: ClassVar[EncodedImageFormat] = ...
    kWBMP: ClassVar[EncodedImageFormat] = ...
    kWEBP: ClassVar[EncodedImageFormat] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class EncodedOrigin:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    kBottomLeft_EncodedOrigin: ClassVar[EncodedOrigin] = ...
    kBottomRight_EncodedOrigin: ClassVar[EncodedOrigin] = ...
    kDefault_EncodedOrigin: ClassVar[EncodedOrigin] = ...
    kLast_EncodedOrigin: ClassVar[EncodedOrigin] = ...
    kLeftBottom_EncodedOrigin: ClassVar[EncodedOrigin] = ...
    kLeftTop_EncodedOrigin: ClassVar[EncodedOrigin] = ...
    kRightBottom_EncodedOrigin: ClassVar[EncodedOrigin] = ...
    kRightTop_EncodedOrigin: ClassVar[EncodedOrigin] = ...
    kTopLeft_EncodedOrigin: ClassVar[EncodedOrigin] = ...
    kTopRight_EncodedOrigin: ClassVar[EncodedOrigin] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class ErodeImageFilter:
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def Make(cls, radiusX: float, radiusY: float, input: ImageFilter = ..., cropRect: ImageFilter.CropRect = ...) -> ImageFilter: ...

class FILEStream(StreamAsset):
    def __init__(self, path: str) -> None: ...
    @classmethod
    def Make(cls, path: str) -> FILEStream: ...
    def close(self) -> None: ...
    def isValid(self) -> bool: ...
    def __enter__(self) -> FILEStream: ...
    def __exit__(self, arg0: object, arg1: object, arg2: object) -> None: ...

class FILEWStream(WStream):
    def __init__(self, path: str) -> None: ...
    def fsync(self) -> None: ...
    def isValid(self) -> bool: ...

class FilterQuality:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    kHigh_FilterQuality: ClassVar[FilterQuality] = ...
    kLast_FilterQuality: ClassVar[FilterQuality] = ...
    kLow_FilterQuality: ClassVar[FilterQuality] = ...
    kMedium_FilterQuality: ClassVar[FilterQuality] = ...
    kNone_FilterQuality: ClassVar[FilterQuality] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class Flattanable(RefCnt):
    class Type:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        kColorFilter_Type: ClassVar[Flattanable.Type] = ...
        kDrawLooper_Type: ClassVar[Flattanable.Type] = ...
        kDrawable_Type: ClassVar[Flattanable.Type] = ...
        kImageFilter_Type: ClassVar[Flattanable.Type] = ...
        kMaskFilter_Type: ClassVar[Flattanable.Type] = ...
        kPathEffect_Type: ClassVar[Flattanable.Type] = ...
        kPixelRef_Type: ClassVar[Flattanable.Type] = ...
        kShaderBase_Type: ClassVar[Flattanable.Type] = ...
        kUnused_Type: ClassVar[Flattanable.Type] = ...
        kUnused_Type2: ClassVar[Flattanable.Type] = ...
        kUnused_Type3: ClassVar[Flattanable.Type] = ...
        kUnused_Type4: ClassVar[Flattanable.Type] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    kColorFilter_Type: ClassVar[Flattanable.Type] = ...
    kDrawLooper_Type: ClassVar[Flattanable.Type] = ...
    kDrawable_Type: ClassVar[Flattanable.Type] = ...
    kImageFilter_Type: ClassVar[Flattanable.Type] = ...
    kMaskFilter_Type: ClassVar[Flattanable.Type] = ...
    kPathEffect_Type: ClassVar[Flattanable.Type] = ...
    kPixelRef_Type: ClassVar[Flattanable.Type] = ...
    kShaderBase_Type: ClassVar[Flattanable.Type] = ...
    kUnused_Type: ClassVar[Flattanable.Type] = ...
    kUnused_Type2: ClassVar[Flattanable.Type] = ...
    kUnused_Type3: ClassVar[Flattanable.Type] = ...
    kUnused_Type4: ClassVar[Flattanable.Type] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def Deserialize(cls, type: Flattanable.Type, b: buffer) -> Flattanable: ...
    def getFlattenableType(self) -> Flattanable.Type: ...
    def getTypeName(self) -> str: ...
    def serialize(self) -> Data: ...

class Font:
    class Edging:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        kAlias: ClassVar[Font.Edging] = ...
        kAntiAlias: ClassVar[Font.Edging] = ...
        kSubpixelAntiAlias: ClassVar[Font.Edging] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    kAlias: ClassVar[Font.Edging] = ...
    kAntiAlias: ClassVar[Font.Edging] = ...
    kSubpixelAntiAlias: ClassVar[Font.Edging] = ...
    __hash__: ClassVar[None] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, typeface: Typeface, size: float) -> None: ...
    @overload
    def __init__(self, typeface: Typeface) -> None: ...
    @overload
    def __init__(self, typeface: Typeface, size: float, scaleX: float, skewX: float) -> None: ...
    def countText(self, text: str, encoding: TextEncoding = ...) -> int: ...
    def dump(self) -> None: ...
    def getBounds(self, glyphs: List[int], paint: SkPaint = ...) -> List[Rect]: ...
    def getEdging(self) -> Font.Edging: ...
    def getHinting(self) -> FontHinting: ...
    def getMetrics(self) -> SkFontMetrics: ...
    def getPath(self, glyphID: int) -> object: ...
    def getPaths(self, glyphIDs: List[int]) -> object: ...
    def getPos(self, glyphs: List[int], origin: Point = ...) -> List[Point]: ...
    def getScaleX(self) -> float: ...
    def getSize(self) -> float: ...
    def getSkewX(self) -> float: ...
    def getSpacing(self) -> float: ...
    def getTypeface(self) -> Typeface: ...
    def getTypefaceOrDefault(self) -> Typeface: ...
    def getWidths(self, glyphs: List[int]) -> List[float]: ...
    def getWidthsBounds(self, glyphs: List[int], paint: SkPaint = ...) -> tuple: ...
    def getXPos(self, glyphs: List[int], origin: float = ...) -> List[float]: ...
    def isBaselineSnap(self) -> bool: ...
    def isEmbeddedBitmaps(self) -> bool: ...
    def isEmbolden(self) -> bool: ...
    def isForceAutoHinting(self) -> bool: ...
    def isLinearMetrics(self) -> bool: ...
    def isSubpixel(self) -> bool: ...
    def makeWithSize(self, size: float) -> Font: ...
    def measureText(self, text: str, encoding: TextEncoding = ..., bounds: Rect = ..., paint: SkPaint = ...) -> float: ...
    def refTypeface(self) -> Typeface: ...
    def refTypefaceOrDefault(self) -> Typeface: ...
    def setBaselineSnap(self, baselineSnap: bool) -> None: ...
    def setEdging(self, edging: Font.Edging) -> None: ...
    def setEmbeddedBitmaps(self, embeddedBitmaps: bool) -> None: ...
    def setEmbolden(self, embolden: bool) -> None: ...
    def setForceAutoHinting(self, forceAutoHinting: bool) -> None: ...
    def setHinting(self, hintingLevel: FontHinting) -> None: ...
    def setLinearMetrics(self, linearMetrics: bool) -> None: ...
    def setScaleX(self, scaleX: float) -> None: ...
    def setSize(self, textSize: float) -> None: ...
    def setSkewX(self, skewX: float) -> None: ...
    def setSubpixel(self, subpixel: bool) -> None: ...
    def setTypeface(self, typeface: Typeface) -> None: ...
    def textToGlyphs(self, text: str, encoding: TextEncoding = ...) -> List[int]: ...
    def unicharToGlyph(self, uni: int) -> int: ...
    def unicharsToGlyphs(self, uni: List[int]) -> List[int]: ...
    def __eq__(self, arg0: Font) -> bool: ...
    def __ne__(self, arg0: Font) -> bool: ...

class FontArguments:
    class VariationPosition:
        class Coordinate:
            axis: int
            value: float
            def __init__(self, axis: int, value: float) -> None: ...
    
        class Coordinates:
            @overload
            def __init__(self) -> None: ...
            @overload
            def __init__(self, arg0: FontArguments.VariationPosition.Coordinates) -> None: ...
            @overload
            def __init__(self, arg0: Iterable) -> None: ...
            def append(self, x: FontArguments.VariationPosition.Coordinate) -> None: ...
            def clear(self) -> None: ...
            @overload
            def extend(self, L: FontArguments.VariationPosition.Coordinates) -> None: ...
            @overload
            def extend(self, L: Iterable) -> None: ...
            def insert(self, i: int, x: FontArguments.VariationPosition.Coordinate) -> None: ...
            @overload
            def pop(self) -> FontArguments.VariationPosition.Coordinate: ...
            @overload
            def pop(self, i: int) -> FontArguments.VariationPosition.Coordinate: ...
            def __bool__(self) -> bool: ...
            @overload
            def __delitem__(self, arg0: int) -> None: ...
            @overload
            def __delitem__(self, arg0: slice) -> None: ...
            @overload
            def __getitem__(self, s: slice) -> FontArguments.VariationPosition.Coordinates: ...
            @overload
            def __getitem__(self, arg0: int) -> FontArguments.VariationPosition.Coordinate: ...
            def __iter__(self) -> Iterator: ...
            def __len__(self) -> int: ...
            @overload
            def __setitem__(self, arg0: int, arg1: FontArguments.VariationPosition.Coordinate) -> None: ...
            @overload
            def __setitem__(self, arg0: slice, arg1: FontArguments.VariationPosition.Coordinates) -> None: ...
        coordinates: FontArguments.VariationPosition.Coordinates
        def __init__(self, coordinates: FontArguments.VariationPosition.Coordinates) -> None: ...
        @property
        def coordinateCount(self) -> int: ...
    def __init__(self) -> None: ...
    def getCollectionIndex(self) -> int: ...
    def getVariationDesignPosition(self) -> FontArguments.VariationPosition: ...
    def setCollectionIndex(self, collectionIndex: int) -> FontArguments: ...
    def setVariationDesignPosition(self, position: FontArguments.VariationPosition) -> FontArguments: ...

class FontHinting:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    kFull: ClassVar[FontHinting] = ...
    kNone: ClassVar[FontHinting] = ...
    kNormal: ClassVar[FontHinting] = ...
    kSlight: ClassVar[FontHinting] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class FontMetrics:
    class FontMetricsFlags:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        kStrikeoutPositionIsValid_Flag: ClassVar[FontMetrics.FontMetricsFlags] = ...
        kStrikeoutThicknessIsValid_Flag: ClassVar[FontMetrics.FontMetricsFlags] = ...
        kUnderlinePositionIsValid_Flag: ClassVar[FontMetrics.FontMetricsFlags] = ...
        kUnderlineThicknessIsValid_Flag: ClassVar[FontMetrics.FontMetricsFlags] = ...
        def __init__(self, value: int) -> None: ...
        def __and__(self, other: object) -> object: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> object: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: object) -> object: ...
        def __rand__(self, other: object) -> object: ...
        def __ror__(self, other: object) -> object: ...
        def __rxor__(self, other: object) -> object: ...
        def __setstate__(self, state: int) -> None: ...
        def __xor__(self, other: object) -> object: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    kStrikeoutPositionIsValid_Flag: ClassVar[FontMetrics.FontMetricsFlags] = ...
    kStrikeoutThicknessIsValid_Flag: ClassVar[FontMetrics.FontMetricsFlags] = ...
    kUnderlinePositionIsValid_Flag: ClassVar[FontMetrics.FontMetricsFlags] = ...
    kUnderlineThicknessIsValid_Flag: ClassVar[FontMetrics.FontMetricsFlags] = ...
    fAscent: float
    fAvgCharWidth: float
    fBottom: float
    fCapHeight: float
    fDescent: float
    fFlags: int
    fLeading: float
    fMaxCharWidth: float
    fStrikeoutPosition: float
    fStrikeoutThickness: float
    fTop: float
    fUnderlinePosition: float
    fUnderlineThickness: float
    fXHeight: float
    fXMax: float
    fXMin: float
    def __init__(self) -> None: ...
    def hasStrikeoutPosition(self, position: float) -> bool: ...
    def hasStrikeoutThickness(self, thickness: float) -> bool: ...
    def hasUnderlinePosition(self, position: float) -> bool: ...
    def hasUnderlineThickness(self, thickness: float) -> bool: ...

class FontMgr(RefCnt):
    def __init__(self) -> None: ...
    @classmethod
    def RefDefault(cls) -> FontMgr: ...
    def countFamilies(self) -> int: ...
    def createStyleSet(self, index: int) -> FontStyleSet: ...
    def getFamilyName(self, index: int) -> str: ...
    def legacyMakeTypeface(self, familyName: str, style: FontStyle) -> Typeface: ...
    def makeFromData(self, data: Data, ttcIndex: int = ...) -> Typeface: ...
    def makeFromFile(self, path: str, ttcIndex: int = ...) -> Typeface: ...
    def matchFamily(self, familyName: str) -> FontStyleSet: ...
    def matchFamilyStyle(self, familyName: object, style: FontStyle) -> Typeface: ...
    def matchFamilyStyleCharacter(self, familyName: str, style: FontStyle, bcp47: List[str], character: int) -> Typeface: ...
    def __getitem__(self, index: int) -> str: ...
    def __len__(self) -> int: ...

class FontParameters:
    class Variation:
        class Axis:
            def: float
            max: float
            min: float
            tag: int
            def __init__(self) -> None: ...
            def isHidden(self) -> bool: ...
            def setHidden(self, hidden: bool) -> None: ...
        def __init__(self, *args, **kwargs) -> None: ...
    def __init__(self, *args, **kwargs) -> None: ...

class FontStyle:
    class Slant:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        kItalic_Slant: ClassVar[FontStyle.Slant] = ...
        kOblique_Slant: ClassVar[FontStyle.Slant] = ...
        kUpright_Slant: ClassVar[FontStyle.Slant] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class Weight:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        kBlack_Weight: ClassVar[FontStyle.Weight] = ...
        kBold_Weight: ClassVar[FontStyle.Weight] = ...
        kExtraBlack_Weight: ClassVar[FontStyle.Weight] = ...
        kExtraBold_Weight: ClassVar[FontStyle.Weight] = ...
        kExtraLight_Weight: ClassVar[FontStyle.Weight] = ...
        kInvisible_Weight: ClassVar[FontStyle.Weight] = ...
        kLight_Weight: ClassVar[FontStyle.Weight] = ...
        kMedium_Weight: ClassVar[FontStyle.Weight] = ...
        kNormal_Weight: ClassVar[FontStyle.Weight] = ...
        kSemiBold_Weight: ClassVar[FontStyle.Weight] = ...
        kThin_Weight: ClassVar[FontStyle.Weight] = ...
        def __init__(self, value: int) -> None: ...
        def __and__(self, other: object) -> object: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> object: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: object) -> object: ...
        def __rand__(self, other: object) -> object: ...
        def __ror__(self, other: object) -> object: ...
        def __rxor__(self, other: object) -> object: ...
        def __setstate__(self, state: int) -> None: ...
        def __xor__(self, other: object) -> object: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class Width:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        kCondensed_Width: ClassVar[FontStyle.Width] = ...
        kExpanded_Width: ClassVar[FontStyle.Width] = ...
        kExtraCondensed_Width: ClassVar[FontStyle.Width] = ...
        kExtraExpanded_Width: ClassVar[FontStyle.Width] = ...
        kNormal_Width: ClassVar[FontStyle.Width] = ...
        kSemiCondensed_Width: ClassVar[FontStyle.Width] = ...
        kSemiExpanded_Width: ClassVar[FontStyle.Width] = ...
        kUltraCondensed_Width: ClassVar[FontStyle.Width] = ...
        kUltraExpanded_Width: ClassVar[FontStyle.Width] = ...
        def __init__(self, value: int) -> None: ...
        def __and__(self, other: object) -> object: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> object: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: object) -> object: ...
        def __rand__(self, other: object) -> object: ...
        def __ror__(self, other: object) -> object: ...
        def __rxor__(self, other: object) -> object: ...
        def __setstate__(self, state: int) -> None: ...
        def __xor__(self, other: object) -> object: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    kBlack_Weight: ClassVar[FontStyle.Weight] = ...
    kBold_Weight: ClassVar[FontStyle.Weight] = ...
    kCondensed_Width: ClassVar[FontStyle.Width] = ...
    kExpanded_Width: ClassVar[FontStyle.Width] = ...
    kExtraBlack_Weight: ClassVar[FontStyle.Weight] = ...
    kExtraBold_Weight: ClassVar[FontStyle.Weight] = ...
    kExtraCondensed_Width: ClassVar[FontStyle.Width] = ...
    kExtraExpanded_Width: ClassVar[FontStyle.Width] = ...
    kExtraLight_Weight: ClassVar[FontStyle.Weight] = ...
    kInvisible_Weight: ClassVar[FontStyle.Weight] = ...
    kItalic_Slant: ClassVar[FontStyle.Slant] = ...
    kLight_Weight: ClassVar[FontStyle.Weight] = ...
    kMedium_Weight: ClassVar[FontStyle.Weight] = ...
    kNormal_Weight: ClassVar[FontStyle.Weight] = ...
    kNormal_Width: ClassVar[FontStyle.Width] = ...
    kOblique_Slant: ClassVar[FontStyle.Slant] = ...
    kSemiBold_Weight: ClassVar[FontStyle.Weight] = ...
    kSemiCondensed_Width: ClassVar[FontStyle.Width] = ...
    kSemiExpanded_Width: ClassVar[FontStyle.Width] = ...
    kThin_Weight: ClassVar[FontStyle.Weight] = ...
    kUltraCondensed_Width: ClassVar[FontStyle.Width] = ...
    kUltraExpanded_Width: ClassVar[FontStyle.Width] = ...
    kUpright_Slant: ClassVar[FontStyle.Slant] = ...
    @overload
    def __init__(self, weight: int, width: int, slant: FontStyle.Slant) -> None: ...
    @overload
    def __init__(self) -> None: ...
    @classmethod
    def Bold(cls) -> FontStyle: ...
    @classmethod
    def BoldItalic(cls) -> FontStyle: ...
    @classmethod
    def Italic(cls) -> FontStyle: ...
    @classmethod
    def Normal(cls) -> FontStyle: ...
    def slant(self) -> FontStyle.Slant: ...
    def weight(self) -> int: ...
    def width(self) -> int: ...

class FontStyleSet(RefCnt):
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def CreateEmpty(cls) -> FontStyleSet: ...
    def count(self) -> int: ...
    def createTypeface(self, index: int) -> Typeface: ...
    def getStyle(self, index: int) -> tuple: ...
    def matchStyle(self, pattern: FontStyle) -> Typeface: ...
    def __getitem__(self, index: int) -> tuple: ...
    def __len__(self) -> int: ...

class GrBackendApi:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    kDawn: ClassVar[GrBackendApi] = ...
    kDirect3D: ClassVar[GrBackendApi] = ...
    kMetal: ClassVar[GrBackendApi] = ...
    kMock: ClassVar[GrBackendApi] = ...
    kOpenGL: ClassVar[GrBackendApi] = ...
    kOpenGL_GrBackend: ClassVar[GrBackendApi] = ...
    kVulkan: ClassVar[GrBackendApi] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class GrBackendFormat:
    __hash__: ClassVar[None] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: GrBackendFormat) -> None: ...
    @classmethod
    def MakeGL(cls, format: int, target: int) -> GrBackendFormat: ...
    @classmethod
    def MakeMock(cls, colorType: GrColorType, compression) -> GrBackendFormat: ...
    @overload
    @classmethod
    def MakeVk(cls, format: VkFormat) -> GrBackendFormat: ...
    @overload
    @classmethod
    def MakeVk(cls, ycbcrInfo: GrVkYcbcrConversionInfo) -> GrBackendFormat: ...
    def asGLFormat(self) -> GrGLFormat: ...
    def asMockColorType(self) -> GrColorType: ...
    def asMockCompressionType(self, *args, **kwargs) -> Any: ...
    def asVkFormat(self, format: VkFormat) -> bool: ...
    def backend(self) -> GrBackendApi: ...
    def channelMask(self) -> int: ...
    def getVkYcbcrConversionInfo(self) -> GrVkYcbcrConversionInfo: ...
    def isValid(self) -> bool: ...
    def makeTexture2D(self) -> GrBackendFormat: ...
    def textureType(self) -> GrTextureType: ...
    def __eq__(self, other: GrBackendFormat) -> bool: ...
    def __ne__(self, other: GrBackendFormat) -> bool: ...

class GrBackendRenderTarget:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, width: int, height: int, sampleCnt: int, stencilBits: int, glInfo: GrGLFramebufferInfo) -> None: ...
    @overload
    def __init__(self, width: int, height: int, sampleCnt: int, stencilBits: int, mockInfo: GrMockRenderTargetInfo) -> None: ...
    def backend(self) -> GrBackendApi: ...
    def dimensions(self) -> ISize: ...
    def getBackendFormat(self) -> GrBackendFormat: ...
    def getGLFramebufferInfo(self, info: GrGLFramebufferInfo) -> bool: ...
    def getMockRenderTargetInfo(self, info: GrMockRenderTargetInfo) -> bool: ...
    def getVkImageInfo(self, info: GrVkImageInfo) -> bool: ...
    def height(self) -> int: ...
    def isFramebufferOnly(self) -> bool: ...
    def isProtected(self) -> bool: ...
    def isValid(self) -> bool: ...
    def sampleCnt(self) -> int: ...
    def setVkImageLayout(self, layout: VkImageLayout) -> None: ...
    def stencilBits(self) -> int: ...
    def width(self) -> int: ...

class GrBackendSemaphore:
    def __init__(self) -> None: ...
    def glSync(self) -> capsule: ...
    def initGL(self, glsync: capsule) -> None: ...
    def initVulkan(self, semaphore: capsule) -> None: ...
    def isInitialized(self) -> bool: ...
    def vkSemaphore(self) -> capsule: ...

class GrBackendSurfaceMutableState:
    def __init__(self) -> None: ...
    def backend(self) -> GrBackendApi: ...
    def isValid(self) -> bool: ...

class GrBackendTexture:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, width: int, height: int, mipMapped: GrMipmapped, glInfo: GrGLTextureInfo) -> None: ...
    @overload
    def __init__(self, width: int, height: int, mipMapped: GrMipmapped, mockInfo: GrMockTextureInfo) -> None: ...
    @overload
    def __init__(self, that: GrBackendTexture) -> None: ...
    def backend(self) -> GrBackendApi: ...
    def dimensions(self) -> ISize: ...
    def getBackendFormat(self) -> GrBackendFormat: ...
    def getGLTextureInfo(self, info: GrGLTextureInfo) -> bool: ...
    def getMockTextureInfo(self, info: GrMockTextureInfo) -> bool: ...
    def getVkImageInfo(self, info: GrVkImageInfo) -> bool: ...
    def glTextureParametersModified(self) -> None: ...
    def hasMipmaps(self) -> bool: ...
    def height(self) -> int: ...
    def isProtected(self) -> bool: ...
    def isSameTexture(self, texture: GrBackendTexture) -> bool: ...
    def isValid(self) -> bool: ...
    def setMutableState(self, state: GrBackendSurfaceMutableState) -> None: ...
    def setVkImageLayout(self, layout: VkImageLayout) -> None: ...
    def width(self) -> int: ...

class GrColorType:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    kABGR_4444: ClassVar[GrColorType] = ...
    kAlpha_16: ClassVar[GrColorType] = ...
    kAlpha_8: ClassVar[GrColorType] = ...
    kAlpha_8xxx: ClassVar[GrColorType] = ...
    kAlpha_F16: ClassVar[GrColorType] = ...
    kAlpha_F32xxx: ClassVar[GrColorType] = ...
    kBGRA_8888: ClassVar[GrColorType] = ...
    kBGR_565: ClassVar[GrColorType] = ...
    kGray_8: ClassVar[GrColorType] = ...
    kGray_8xxx: ClassVar[GrColorType] = ...
    kGray_F16: ClassVar[GrColorType] = ...
    kLast: ClassVar[GrColorType] = ...
    kRGBA_1010102: ClassVar[GrColorType] = ...
    kRGBA_16161616: ClassVar[GrColorType] = ...
    kRGBA_8888: ClassVar[GrColorType] = ...
    kRGBA_8888_SRGB: ClassVar[GrColorType] = ...
    kRGBA_F16: ClassVar[GrColorType] = ...
    kRGBA_F16_Clamped: ClassVar[GrColorType] = ...
    kRGBA_F32: ClassVar[GrColorType] = ...
    kRGB_888: ClassVar[GrColorType] = ...
    kRGB_888x: ClassVar[GrColorType] = ...
    kRG_1616: ClassVar[GrColorType] = ...
    kRG_88: ClassVar[GrColorType] = ...
    kRG_F16: ClassVar[GrColorType] = ...
    kR_16: ClassVar[GrColorType] = ...
    kR_8: ClassVar[GrColorType] = ...
    kR_F16: ClassVar[GrColorType] = ...
    kUnknown: ClassVar[GrColorType] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class GrContext(GrRecordingContext):
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def ComputeImageSize(cls, image: SkImage, mipMapped: GrMipmapped, useNextPow2: bool = ...) -> int: ...
    def abandonContext(self) -> None: ...
    def abandoned(self) -> bool: ...
    def checkAsyncWorkCompletion(self) -> None: ...
    def colorTypeSupportedAsImage(self, colorType: SkColorType) -> bool: ...
    def colorTypeSupportedAsSurface(self, colorType: SkColorType) -> bool: ...
    def compressedBackendFormat(self, compressionType) -> GrBackendFormat: ...
    @overload
    def createBackendTexture(self, width: int, height: int, backendFormat: GrBackendFormat, mipMapped: GrMipmapped, renderable: GrRenderable, isProtected: GrProtected = ...) -> GrBackendTexture: ...
    @overload
    def createBackendTexture(self, width: int, height: int, colorType: SkColorType, mipMapped: GrMipmapped, renderable: GrRenderable, isProtected: GrProtected = ...) -> GrBackendTexture: ...
    @overload
    def createBackendTexture(self, width: int, height: int, backendFormat: GrBackendFormat, color: Color4f, mipMapped: GrMipmapped, renderable: GrRenderable, isProtected: GrProtected = ...) -> GrBackendTexture: ...
    @overload
    def createBackendTexture(self, width: int, height: int, colorType: SkColorType, color: Color4f, mipMapped: GrMipmapped, renderable: GrRenderable, isProtected: GrProtected = ...) -> GrBackendTexture: ...
    @overload
    def createBackendTexture(self, srcData: List[SkPixmap], renderable: GrRenderable, isProtected: GrProtected = ...) -> GrBackendTexture: ...
    @overload
    def createBackendTexture(self, pixmap: SkPixmap, renderable: GrRenderable, isProtected: GrProtected = ...) -> GrBackendTexture: ...
    @overload
    def createCompressedBackendTexture(self, width: int, height: int, backendFormat: GrBackendFormat, color: Color4f, mipMapped: GrMipmapped, isProtected: GrProtected = ...) -> GrBackendTexture: ...
    @overload
    def createCompressedBackendTexture(self, width: int, height: int, type, color: Color4f, mipMapped: GrMipmapped, isProtected: GrProtected = ...) -> GrBackendTexture: ...
    @overload
    def createCompressedBackendTexture(self, width: int, height: int, backendFormat: GrBackendFormat, data: buffer, mipMapped: GrMipmapped, isProtected: GrProtected = ...) -> GrBackendTexture: ...
    @overload
    def createCompressedBackendTexture(self, width: int, height: int, type, data: buffer, mipMapped: GrMipmapped, isProtected: GrProtected = ...) -> GrBackendTexture: ...
    def defaultBackendFormat(self, colorType: SkColorType, renderable: GrRenderable = ...) -> GrBackendFormat: ...
    def deleteBackendTexture(self, texture: GrBackendTexture) -> None: ...
    @overload
    def flush(self, info: GrFlushInfo) -> GrSemaphoresSubmitted: ...
    @overload
    def flush(self) -> None: ...
    def flushAndSubmit(self) -> None: ...
    def freeGpuResources(self) -> None: ...
    def getResourceCacheLimit(self) -> int: ...
    def getResourceCachePurgeableBytes(self) -> int: ...
    def getResourceCacheUsage(self, resourceCount: int = ..., maxResourceBytes: int = ...) -> None: ...
    def maxRenderTargetSize(self) -> int: ...
    def maxSurfaceSampleCountForColorType(self, colorType: SkColorType) -> int: ...
    def maxTextureSize(self) -> int: ...
    def oomed(self) -> bool: ...
    def performDeferredCleanup(self, msNotUsed: datetime.timedelta) -> None: ...
    def precompileShader(self, key: Data, data: Data) -> bool: ...
    def purgeResourcesNotUsedInMs(self, msNotUsed: datetime.timedelta) -> None: ...
    @overload
    def purgeUnlockedResources(self, maxBytesToPurge: int, preferScratchResources: bool) -> None: ...
    @overload
    def purgeUnlockedResources(self, scratchResourcesOnly: bool) -> None: ...
    def releaseResourcesAndAbandonContext(self) -> None: ...
    def resetContext(self, state: int = ...) -> None: ...
    def resetGLTextureBindings(self) -> None: ...
    def setBackendRenderTargetState(self, target: GrBackendRenderTarget, mutableState: GrBackendSurfaceMutableState, previousState: GrBackendSurfaceMutableState = ...) -> bool: ...
    def setBackendTextureState(self, texture: GrBackendTexture, mutableState: GrBackendSurfaceMutableState, previousState: GrBackendSurfaceMutableState = ...) -> bool: ...
    def setResourceCacheLimit(self, maxResourceBytes: int) -> None: ...
    def storeVkPipelineCacheData(self) -> None: ...
    def submit(self, syncCpu: bool = ...) -> bool: ...
    def supportsDistanceFieldText(self) -> bool: ...
    @overload
    def updateBackendTexture(self, backendTexture: GrBackendTexture, color: Color4f) -> bool: ...
    @overload
    def updateBackendTexture(self, backendTexture: GrBackendTexture, srcData: List[SkPixmap]) -> bool: ...
    def wait(self, semaphores: List[GrBackendSemaphore], deleteSemaphoresAfterWait: bool = ...) -> bool: ...

class GrContextOptions:
    def __init__(self) -> None: ...

class GrContext_Base(RefCnt):
    def __init__(self, *args, **kwargs) -> None: ...
    def asDirectContext(self) -> GrDirectContext: ...
    def backend(self) -> GrBackendApi: ...
    def compressedBackendFormat(self, arg0) -> GrBackendFormat: ...
    def defaultBackendFormat(self, arg0: SkColorType, arg1: GrRenderable) -> GrBackendFormat: ...
    def threadSafeProxy(self) -> GrContextThreadSafeProxy: ...

class GrDirectContext(GrContext):
    def __init__(self, *args, **kwargs) -> None: ...
    @overload
    @classmethod
    def MakeGL(cls, interface: GrGLInterface, options: GrContextOptions) -> GrDirectContext: ...
    @overload
    @classmethod
    def MakeGL(cls, interface: GrGLInterface) -> GrDirectContext: ...
    @overload
    @classmethod
    def MakeGL(cls, options: GrContextOptions) -> GrDirectContext: ...
    @overload
    @classmethod
    def MakeGL(cls) -> GrDirectContext: ...
    @overload
    @classmethod
    def MakeMock(cls, mockOptions: GrMockOptions, options: GrContextOptions) -> GrDirectContext: ...
    @overload
    @classmethod
    def MakeMock(cls, mockOptions: GrMockOptions) -> GrDirectContext: ...
    def abandonContext(self) -> None: ...
    def freeGpuResources(self) -> None: ...
    def releaseResourcesAndAbandonContext(self) -> None: ...

class GrFlushInfo:
    semaphores: object
    def __init__(self) -> None: ...
    @property
    def fNumSemaphores(self) -> int: ...

class GrGLBackendState:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    kALL_GrGLBackendState: ClassVar[GrGLBackendState] = ...
    kBlend_GrGLBackendState: ClassVar[GrGLBackendState] = ...
    kFixedFunction_GrGLBackendState: ClassVar[GrGLBackendState] = ...
    kMSAAEnable_GrGLBackendState: ClassVar[GrGLBackendState] = ...
    kMisc_GrGLBackendState: ClassVar[GrGLBackendState] = ...
    kPathRendering_GrGLBackendState: ClassVar[GrGLBackendState] = ...
    kPixelStore_GrGLBackendState: ClassVar[GrGLBackendState] = ...
    kProgram_GrGLBackendState: ClassVar[GrGLBackendState] = ...
    kRenderTarget_GrGLBackendState: ClassVar[GrGLBackendState] = ...
    kStencil_GrGLBackendState: ClassVar[GrGLBackendState] = ...
    kTextureBinding_GrGLBackendState: ClassVar[GrGLBackendState] = ...
    kVertex_GrGLBackendState: ClassVar[GrGLBackendState] = ...
    kView_GrGLBackendState: ClassVar[GrGLBackendState] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class GrGLFormat:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    kALPHA8: ClassVar[GrGLFormat] = ...
    kBGRA8: ClassVar[GrGLFormat] = ...
    kCOMPRESSED_ETC1_RGB8: ClassVar[GrGLFormat] = ...
    kCOMPRESSED_RGB8_BC1: ClassVar[GrGLFormat] = ...
    kCOMPRESSED_RGB8_ETC2: ClassVar[GrGLFormat] = ...
    kCOMPRESSED_RGBA8_BC1: ClassVar[GrGLFormat] = ...
    kLUMINANCE16F: ClassVar[GrGLFormat] = ...
    kLUMINANCE8: ClassVar[GrGLFormat] = ...
    kLast: ClassVar[GrGLFormat] = ...
    kR16: ClassVar[GrGLFormat] = ...
    kR16F: ClassVar[GrGLFormat] = ...
    kR8: ClassVar[GrGLFormat] = ...
    kRG16: ClassVar[GrGLFormat] = ...
    kRG16F: ClassVar[GrGLFormat] = ...
    kRG8: ClassVar[GrGLFormat] = ...
    kRGB10_A2: ClassVar[GrGLFormat] = ...
    kRGB565: ClassVar[GrGLFormat] = ...
    kRGB8: ClassVar[GrGLFormat] = ...
    kRGBA16: ClassVar[GrGLFormat] = ...
    kRGBA16F: ClassVar[GrGLFormat] = ...
    kRGBA4: ClassVar[GrGLFormat] = ...
    kRGBA8: ClassVar[GrGLFormat] = ...
    kSRGB8_ALPHA8: ClassVar[GrGLFormat] = ...
    kUnknown: ClassVar[GrGLFormat] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class GrGLFramebufferInfo:
    __hash__: ClassVar[None] = ...
    fFBOID: int
    fFormat: int
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, FBOID: int, format: int = ...) -> None: ...
    def __eq__(self, arg0: GrGLFramebufferInfo) -> bool: ...

class GrGLInterface(RefCnt):
    def __init__(self) -> None: ...

class GrGLTextureInfo:
    __hash__: ClassVar[None] = ...
    fFormat: int
    fID: int
    fTarget: int
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, target: int, id: int, format: int = ...) -> None: ...
    def __eq__(self, arg0: GrGLTextureInfo) -> bool: ...

class GrImageContext(GrContext_Base):
    def __init__(self, *args, **kwargs) -> None: ...

class GrMipmapped:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    kNo: ClassVar[GrMipmapped] = ...
    kYes: ClassVar[GrMipmapped] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class GrMockOptions:
    def __init__(self) -> None: ...

class GrMockRenderTargetInfo:
    __hash__: ClassVar[None] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, colorType: GrColorType, id: int) -> None: ...
    def colorType(self) -> GrColorType: ...
    def getBackendFormat(self) -> GrBackendFormat: ...
    def __eq__(self, arg0: GrMockRenderTargetInfo) -> bool: ...

class GrMockTextureInfo:
    __hash__: ClassVar[None] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, colorType: GrColorType, compressionType, id: int) -> None: ...
    def colorType(self) -> GrColorType: ...
    def compressionType(self, *args, **kwargs) -> Any: ...
    def getBackendFormat(self) -> GrBackendFormat: ...
    def id(self) -> int: ...
    def __eq__(self, arg0: GrMockTextureInfo) -> bool: ...

class GrProtected:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    kNo: ClassVar[GrProtected] = ...
    kYes: ClassVar[GrProtected] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class GrRecordingContext(GrImageContext):
    def __init__(self, *args, **kwargs) -> None: ...
    def abandoned(self) -> bool: ...
    def colorTypeSupportedAsImage(self, arg0: SkColorType) -> bool: ...
    def colorTypeSupportedAsSurface(self, colorType: SkColorType) -> bool: ...
    def defaultBackendFormat(self, colorType: SkColorType, renderable: GrRenderable = ...) -> GrBackendFormat: ...
    def maxRenderTargetSize(self) -> int: ...
    def maxSurfaceSampleCountForColorType(self, arg0: SkColorType) -> int: ...
    def maxTextureSize(self) -> int: ...

class GrRenderable:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    kNo: ClassVar[GrRenderable] = ...
    kYes: ClassVar[GrRenderable] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class GrSemaphoresSubmitted:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    kNo: ClassVar[GrSemaphoresSubmitted] = ...
    kYes: ClassVar[GrSemaphoresSubmitted] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class GrSurfaceOrigin:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    kBottomLeft_GrSurfaceOrigin: ClassVar[GrSurfaceOrigin] = ...
    kTopLeft_GrSurfaceOrigin: ClassVar[GrSurfaceOrigin] = ...
    def __init__(self, value: int) -> None: ...
    def __and__(self, other: object) -> object: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __invert__(self) -> object: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __or__(self, other: object) -> object: ...
    def __rand__(self, other: object) -> object: ...
    def __ror__(self, other: object) -> object: ...
    def __rxor__(self, other: object) -> object: ...
    def __setstate__(self, state: int) -> None: ...
    def __xor__(self, other: object) -> object: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class GrTextureType:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    k2D: ClassVar[GrTextureType] = ...
    kExternal: ClassVar[GrTextureType] = ...
    kNone: ClassVar[GrTextureType] = ...
    kRectangle: ClassVar[GrTextureType] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class GrVkAlloc:
    def __init__(self) -> None: ...

class GrVkBackendContext:
    def __init__(self) -> None: ...

class GrVkDrawableInfo:
    def __init__(self, *args, **kwargs) -> None: ...

class GrVkExtensionFlags:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    kEXT_debug_report_GrVkExtensionFlag: ClassVar[GrVkExtensionFlags] = ...
    kKHR_android_surface_GrVkExtensionFlag: ClassVar[GrVkExtensionFlags] = ...
    kKHR_surface_GrVkExtensionFlag: ClassVar[GrVkExtensionFlags] = ...
    kKHR_swapchain_GrVkExtensionFlag: ClassVar[GrVkExtensionFlags] = ...
    kKHR_win32_surface_GrVkExtensionFlag: ClassVar[GrVkExtensionFlags] = ...
    kKHR_xcb_surface_GrVkExtensionFlag: ClassVar[GrVkExtensionFlags] = ...
    kNV_glsl_shader_GrVkExtensionFlag: ClassVar[GrVkExtensionFlags] = ...
    def __init__(self, value: int) -> None: ...
    def __and__(self, other: object) -> object: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __invert__(self) -> object: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __or__(self, other: object) -> object: ...
    def __rand__(self, other: object) -> object: ...
    def __ror__(self, other: object) -> object: ...
    def __rxor__(self, other: object) -> object: ...
    def __setstate__(self, state: int) -> None: ...
    def __xor__(self, other: object) -> object: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class GrVkFeatureFlags:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    kDualSrcBlend_GrVkFeatureFlag: ClassVar[GrVkFeatureFlags] = ...
    kGeometryShader_GrVkFeatureFlag: ClassVar[GrVkFeatureFlags] = ...
    kSampleRateShading_GrVkFeatureFlag: ClassVar[GrVkFeatureFlags] = ...
    def __init__(self, value: int) -> None: ...
    def __and__(self, other: object) -> object: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __invert__(self) -> object: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __or__(self, other: object) -> object: ...
    def __rand__(self, other: object) -> object: ...
    def __ror__(self, other: object) -> object: ...
    def __rxor__(self, other: object) -> object: ...
    def __setstate__(self, state: int) -> None: ...
    def __xor__(self, other: object) -> object: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class GrVkImageInfo:
    fAlloc: GrVkAlloc
    fCurrentQueueFamily: int
    fLevelCount: int
    fProtected: GrProtected
    fSharingMode: VkSharingMode
    fYcbcrConversionInfo: GrVkYcbcrConversionInfo
    def __init__(self) -> None: ...

class GrVkYcbcrConversionInfo:
    def __init__(self) -> None: ...

class GradientShader:
    class Flags:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        kInterpolateColorsInPremul_Flag: ClassVar[GradientShader.Flags] = ...
        def __init__(self, value: int) -> None: ...
        def __and__(self, other: object) -> object: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> object: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: object) -> object: ...
        def __rand__(self, other: object) -> object: ...
        def __ror__(self, other: object) -> object: ...
        def __rxor__(self, other: object) -> object: ...
        def __setstate__(self, state: int) -> None: ...
        def __xor__(self, other: object) -> object: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    kInterpolateColorsInPremul_Flag: ClassVar[GradientShader.Flags] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def MakeLinear(cls, points: List[Point], colors: List[int], positions: object = ..., mode: TileMode = ..., flags: int = ..., localMatrix: Matrix = ...) -> Shader: ...
    @classmethod
    def MakeRadial(cls, center: Point, radius: float, colors: List[int], positions: object = ..., mode: TileMode = ..., flags: int = ..., localMatrix: Matrix = ...) -> Shader: ...
    @classmethod
    def MakeSweep(cls, cx: float, cy: float, colors: List[int], positions: object = ..., mode: TileMode = ..., startAngle: float = ..., endAngle: float = ..., flags: int = ..., localMatrix: Matrix = ...) -> Shader: ...
    @classmethod
    def MakeTwoPointConical(cls, start: Point, startRadius: float, end: Point, endRadius: float, colors: List[int], positions: object = ..., mode: TileMode = ..., flags: int = ..., localMatrix: Matrix = ...) -> Shader: ...

class HighContrastConfig:
    class InvertStyle:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        kInvertBrightness: ClassVar[HighContrastConfig.InvertStyle] = ...
        kInvertLightness: ClassVar[HighContrastConfig.InvertStyle] = ...
        kLast: ClassVar[HighContrastConfig.InvertStyle] = ...
        kNoInvert: ClassVar[HighContrastConfig.InvertStyle] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    kInvertBrightness: ClassVar[HighContrastConfig.InvertStyle] = ...
    kInvertLightness: ClassVar[HighContrastConfig.InvertStyle] = ...
    kLast: ClassVar[HighContrastConfig.InvertStyle] = ...
    kNoInvert: ClassVar[HighContrastConfig.InvertStyle] = ...
    fContrast: float
    fGrayscale: bool
    fInvertStyle: HighContrastConfig.InvertStyle
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, grayscale: bool, invertStyle: HighContrastConfig.InvertStyle, contrast: float) -> None: ...
    def isValid(self) -> bool: ...

class HighContrastFilter:
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def Make(cls, config: HighContrastConfig) -> ColorFilter: ...

class IPoint:
    __hash__: ClassVar[None] = ...
    fX: int
    fY: int
    @overload
    def __init__(self, x: int, y: int) -> None: ...
    @overload
    def __init__(self, t: tuple) -> None: ...
    @classmethod
    def Make(cls, x: int, y: int) -> IPoint: ...
    def equals(self, x: int, y: int) -> bool: ...
    def isZero(self) -> bool: ...
    def set(self, x: int, y: int) -> None: ...
    def x(self) -> int: ...
    def y(self) -> int: ...
    def __add__(self, other: IPoint) -> IPoint: ...
    def __eq__(self, other: IPoint) -> bool: ...
    def __iadd__(self, v: IPoint) -> IPoint: ...
    def __isub__(self, v: IPoint) -> IPoint: ...
    def __iter__(self) -> Iterator: ...
    def __len__(self) -> int: ...
    def __ne__(self, other: IPoint) -> bool: ...
    def __neg__(self) -> IPoint: ...
    def __sub__(self, other: IPoint) -> IPoint: ...

class IRect:
    __hash__: ClassVar[None] = ...
    fBottom: int
    fLeft: int
    fRight: int
    fTop: int
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, w: int, h: int) -> None: ...
    @overload
    def __init__(self, l: int, t: int, r: int, b: int) -> None: ...
    @overload
    def __init__(self, t: tuple) -> None: ...
    @classmethod
    def Intersects(cls, a: IRect, b: IRect) -> bool: ...
    @classmethod
    def MakeEmpty(cls) -> IRect: ...
    @classmethod
    def MakeLTRB(cls, l: int, t: int, r: int, b: int) -> IRect: ...
    @classmethod
    def MakeSize(cls, size: ISize) -> IRect: ...
    @classmethod
    def MakeWH(cls, w: int, h: int) -> IRect: ...
    @classmethod
    def MakeXYWH(cls, x: int, y: int, w: int, h: int) -> IRect: ...
    def adjust(self, dL: int, dT: int, dR: int, dB: int) -> None: ...
    def bottom(self) -> int: ...
    @overload
    def contains(self, x: int, y: int) -> bool: ...
    @overload
    def contains(self, r: IRect) -> bool: ...
    @overload
    def contains(self, r: SkRect) -> bool: ...
    def containsNoEmptyCheck(self, r: IRect) -> bool: ...
    def height(self) -> int: ...
    def height64(self) -> int: ...
    def inset(self, dx: int, dy: int) -> None: ...
    @overload
    def intersect(self, r: IRect) -> bool: ...
    @overload
    def intersect(self, a: IRect, b: IRect) -> bool: ...
    def isEmpty(self) -> bool: ...
    def isEmpty64(self) -> bool: ...
    def join(self, r: IRect) -> None: ...
    def left(self) -> int: ...
    def makeInset(self, dx: int, dy: int) -> IRect: ...
    @overload
    def makeOffset(self, dx: int, dy: int) -> IRect: ...
    @overload
    def makeOffset(self, offset: IPoint) -> IRect: ...
    def makeOutset(self, dx: int, dy: int) -> IRect: ...
    def makeSorted(self) -> IRect: ...
    @overload
    def offset(self, dx: int, dy: int) -> None: ...
    @overload
    def offset(self, delta: IPoint) -> None: ...
    def offsetTo(self, newX: int, newY: int) -> None: ...
    def outset(self, dx: int, dy: int) -> None: ...
    def right(self) -> int: ...
    def setEmpty(self) -> None: ...
    def setLTRB(self, left: int, top: int, right: int, bottom: int) -> None: ...
    def setWH(self, width: int, height: int) -> None: ...
    def setXYWH(self, x: int, y: int, width: int, height: int) -> None: ...
    def size(self) -> ISize: ...
    def sort(self) -> None: ...
    def top(self) -> int: ...
    def topLeft(self) -> IPoint: ...
    def width(self) -> int: ...
    def width64(self) -> int: ...
    def x(self) -> int: ...
    def y(self) -> int: ...
    @overload
    def __contains__(self, arg0: IPoint) -> bool: ...
    @overload
    def __contains__(self, arg0: IRect) -> bool: ...
    @overload
    def __contains__(self, arg0: SkRect) -> bool: ...
    def __eq__(self, other: IRect) -> bool: ...
    def __iter__(self) -> Iterator: ...
    def __len__(self) -> int: ...
    def __ne__(self, other: IRect) -> bool: ...

class ISize:
    __hash__: ClassVar[None] = ...
    fHeight: int
    fWidth: int
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, width: int, height: int) -> None: ...
    @overload
    def __init__(self, t: tuple) -> None: ...
    @classmethod
    def Make(cls, width: int, height: int) -> ISize: ...
    @classmethod
    def MakeEmpty(cls) -> ISize: ...
    def area(self) -> int: ...
    def equals(self, width: int, height: int) -> bool: ...
    def height(self) -> int: ...
    def isEmpty(self) -> bool: ...
    def isZero(self) -> bool: ...
    def set(self, width: int, height: int) -> None: ...
    def setEmpty(self) -> None: ...
    def width(self) -> int: ...
    def __eq__(self, other: ISize) -> bool: ...
    def __iter__(self) -> Iterator: ...
    def __len__(self) -> int: ...
    def __ne__(self, other: ISize) -> bool: ...

class Image(RefCnt):
    class BitDepth:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        kF16: ClassVar[Image.BitDepth] = ...
        kU8: ClassVar[Image.BitDepth] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class CachingHint:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        kAllow_CachingHint: ClassVar[Image.CachingHint] = ...
        kDisallow_CachingHint: ClassVar[Image.CachingHint] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class CompressionType:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        kBC1_RGB8_UNORM: ClassVar[Image.CompressionType] = ...
        kBC1_RGBA8_UNORM: ClassVar[Image.CompressionType] = ...
        kETC2_RGB8_UNORM: ClassVar[Image.CompressionType] = ...
        kLast: ClassVar[Image.CompressionType] = ...
        kNone: ClassVar[Image.CompressionType] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class LegacyBitmapMode:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        kRO_LegacyBitmapMode: ClassVar[Image.LegacyBitmapMode] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    kAllow_CachingHint: ClassVar[Image.CachingHint] = ...
    kBC1_RGB8_UNORM: ClassVar[Image.CompressionType] = ...
    kBC1_RGBA8_UNORM: ClassVar[Image.CompressionType] = ...
    kDisallow_CachingHint: ClassVar[Image.CachingHint] = ...
    kETC2_RGB8_UNORM: ClassVar[Image.CompressionType] = ...
    kF16: ClassVar[Image.BitDepth] = ...
    kLast: ClassVar[Image.CompressionType] = ...
    kNone: ClassVar[Image.CompressionType] = ...
    kRO_LegacyBitmapMode: ClassVar[Image.LegacyBitmapMode] = ...
    kU8: ClassVar[Image.BitDepth] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def MakeBackendTextureFromImage(cls, context: GrDirectContext, image: Image, backendTexture: GrBackendTexture) -> bool: ...
    @classmethod
    def MakeCrossContextFromPixmap(cls, context: GrDirectContext, pixmap: SkPixmap, buildMips: bool, limitToMaxTextureSize: bool = ...) -> Image: ...
    @classmethod
    def MakeFromAdoptedTexture(cls, context: GrRecordingContext, backendTexture: GrBackendTexture, origin: GrSurfaceOrigin, colorType: ColorType, alphaType: AlphaType = ..., colorSpace: ColorSpace = ...) -> Image: ...
    @classmethod
    def MakeFromBitmap(cls, bitmap: Bitmap) -> Image: ...
    @classmethod
    def MakeFromCompressedTexture(cls, context: GrRecordingContext, texture: GrBackendTexture, origin: GrSurfaceOrigin, alphaType: AlphaType, colorSpace: ColorSpace = ...) -> Image: ...
    @classmethod
    def MakeFromEncoded(cls, encoded: Data) -> Image: ...
    @classmethod
    def MakeFromNV12TexturesCopy(cls, context: GrContext, yuvColorSpace: YUVColorSpace, nv12Textures, std, imageOrigin: GrSurfaceOrigin, imageColorSpace: ColorSpace = ...) -> Image: ...
    @classmethod
    def MakeFromNV12TexturesCopyWithExternalBackend(cls, context: GrContext, yuvColorSpace: YUVColorSpace, nv12Textures, std, imageOrigin: GrSurfaceOrigin, backendTexture: GrBackendTexture, imageColorSpace: ColorSpace = ...) -> Image: ...
    @classmethod
    def MakeFromPicture(cls, picture: SkPicture, dimensions: ISize, matrix: Matrix = ..., paint: SkPaint = ..., bitDepth: Image.BitDepth = ..., colorSpace: ColorSpace = ...) -> Image: ...
    @classmethod
    def MakeFromRaster(cls, pixmap: SkPixmap) -> Image: ...
    @classmethod
    def MakeFromTexture(cls, context: GrRecordingContext, texture: GrBackendTexture, origin: GrSurfaceOrigin, colorType: ColorType, alphaType: AlphaType, colorSpace: ColorSpace = ...) -> Image: ...
    @classmethod
    def MakeFromYUVAPixmaps(cls, context: GrRecordingContext, pixmaps: SkYUVAPixmaps, buildMips: GrMipmapped = ..., limitToMaxTextureSize: bool = ..., imageColorSpace: ColorSpace = ...) -> Image: ...
    @classmethod
    def MakeFromYUVATextures(cls, *args, **kwargs) -> Any: ...
    @classmethod
    def MakeFromYUVATexturesCopy(cls, *args, **kwargs) -> Any: ...
    @classmethod
    def MakeFromYUVATexturesCopyWithExternalBackend(cls, *args, **kwargs) -> Any: ...
    @classmethod
    def MakeRasterCopy(cls, pixmap: SkPixmap) -> Image: ...
    @classmethod
    def MakeRasterData(cls, info: ImageInfo, pixels: buffer, rowBytes: int) -> Image: ...
    @classmethod
    def MakeRasterFromCompressed(cls, data: Data, width: int, height: int, type: Image.CompressionType) -> Image: ...
    @classmethod
    def MakeTextureFromCompressed(cls, context: GrDirectContext, data: Data, width: int, height: int, type: Image.CompressionType, mipMapped: GrMipmapped = ..., isProtected: GrProtected = ...) -> Image: ...
    def _repr_png_(self) -> bytes: ...
    def alphaType(self) -> AlphaType: ...
    def asLegacyBitmap(self, bitmap: Bitmap, legacyBitmapMode: Image.LegacyBitmapMode = ...) -> bool: ...
    def bitmap(self, colorType: ColorType = ..., alphaType: AlphaType = ..., colorSpace: ColorSpace = ...) -> Bitmap: ...
    def bounds(self) -> IRect: ...
    def colorSpace(self) -> ColorSpace: ...
    def colorType(self) -> ColorType: ...
    def convert(self, colorType: ColorType = ..., alphaType: AlphaType = ..., colorSpace: ColorSpace = ...) -> Image: ...
    def dimensions(self) -> ISize: ...
    @overload
    def encodeToData(self, encodedImageFormat: EncodedImageFormat, quality: int) -> Data: ...
    @overload
    def encodeToData(self) -> Data: ...
    @overload
    def flush(self, arg0: GrDirectContext, arg1: GrFlushInfo) -> GrSemaphoresSubmitted: ...
    @overload
    def flush(self, context: GrDirectContext) -> None: ...
    def flushAndSubmit(self, context: GrDirectContext) -> None: ...
    @classmethod
    def fromarray(cls, array: numpy.ndarray, colorType: ColorType = ..., alphaType: AlphaType = ..., colorSpace: ColorSpace = ..., copy: bool = ...) -> Image: ...
    @classmethod
    def frombytes(cls, array: buffer, dimensions: ISize, colorType: ColorType = ..., alphaType: AlphaType = ..., colorSpace: ColorSpace = ..., copy: bool = ...) -> Image: ...
    def getBackendTexture(self, flushPendingGrContextIO: bool, origin: GrSurfaceOrigin = ...) -> GrBackendTexture: ...
    def hasMipmaps(self) -> bool: ...
    def height(self) -> int: ...
    def imageInfo(self) -> ImageInfo: ...
    def isAlphaOnly(self) -> bool: ...
    def isLazyGenerated(self) -> bool: ...
    def isOpaque(self) -> bool: ...
    def isTextureBacked(self) -> bool: ...
    def isValid(self, context: GrRecordingContext = ...) -> bool: ...
    def makeColorSpace(self, target: ColorSpace, direct: GrDirectContext = ...) -> Image: ...
    def makeColorTypeAndColorSpace(self, targetColorType: ColorType, targetColorSpace: ColorSpace = ..., direct: GrDirectContext = ...) -> Image: ...
    def makeNonTextureImage(self) -> Image: ...
    def makeRasterImage(self, cachingHint: Image.CachingHint = ...) -> Image: ...
    def makeShader(self, tmx: TileMode = ..., tmy: TileMode = ..., localMatrix: Matrix = ...) -> SkShader: ...
    def makeSubset(self, subset: IRect, direct: GrDirectContext = ...) -> Image: ...
    def makeTextureImage(self, context: GrDirectContext, mipMapped: GrMipmapped = ..., budgeted: Budgeted = ...) -> Image: ...
    def makeWithFilter(self, context: GrRecordingContext, filter: SkImageFilter, subset: IRect, clipBounds: IRect, outSubset: IRect, offset: IPoint) -> Image: ...
    @classmethod
    def open(cls, fp: object) -> Image: ...
    def peekPixels(self, pixmap: SkPixmap) -> bool: ...
    @overload
    def readPixels(self, context: GrDirectContext, dstInfo: ImageInfo, dstPixels: buffer, dstRowBytes: int, srcX: int = ..., srcY: int = ..., cachingHint: Image.CachingHint = ...) -> bool: ...
    @overload
    def readPixels(self, context: GrDirectContext, dst: SkPixmap, srcX: int, srcY: int, cachingHint: Image.CachingHint = ...) -> bool: ...
    @overload
    def readPixels(self, dstInfo: ImageInfo, dstPixels: buffer, dstRowBytes: int, srcX: int = ..., srcY: int = ..., cachingHint: Image.CachingHint = ...) -> bool: ...
    @overload
    def readPixels(self, dst: SkPixmap, srcX: int, srcY: int, cachingHint: Image.CachingHint = ...) -> bool: ...
    def refColorSpace(self) -> ColorSpace: ...
    def refEncodedData(self) -> Data: ...
    def reinterpretColorSpace(self, newColorSpace: ColorSpace = ...) -> Image: ...
    def resize(self, width: int, height: int, filterQuality: FilterQuality = ..., cachingHint: Image.CachingHint = ...) -> Image: ...
    def save(self, fp: object, encodedImageFormat: EncodedImageFormat = ..., quality: int = ...) -> None: ...
    def scalePixels(self, dst: SkPixmap, filterQuality: FilterQuality = ..., cachingHint: Image.CachingHint = ...) -> bool: ...
    def toarray(self, srcX: int = ..., srcY: int = ..., colorType: ColorType = ..., alphaType: AlphaType = ..., colorSpace: ColorSpace = ...) -> numpy.ndarray: ...
    def tobytes(self) -> object: ...
    def uniqueID(self) -> int: ...
    def width(self) -> int: ...
    def withDefaultMipmaps(self) -> Image: ...
    @property
    def __array_interface__(self) -> dict: ...

class ImageFilter(Flattanable):
    class CropRect:
        class CropEdge:
            __members__: ClassVar[dict] = ...  # read-only
            __entries: ClassVar[dict] = ...
            kHasAll_CropEdge: ClassVar[ImageFilter.CropRect.CropEdge] = ...
            kHasHeight_CropEdge: ClassVar[ImageFilter.CropRect.CropEdge] = ...
            kHasLeft_CropEdge: ClassVar[ImageFilter.CropRect.CropEdge] = ...
            kHasTop_CropEdge: ClassVar[ImageFilter.CropRect.CropEdge] = ...
            kHasWidth_CropEdge: ClassVar[ImageFilter.CropRect.CropEdge] = ...
            def __init__(self, value: int) -> None: ...
            def __eq__(self, other: object) -> bool: ...
            def __getstate__(self) -> int: ...
            def __hash__(self) -> int: ...
            def __index__(self) -> int: ...
            def __int__(self) -> int: ...
            def __ne__(self, other: object) -> bool: ...
            def __setstate__(self, state: int) -> None: ...
            @property
            def name(self) -> str: ...
            @property
            def value(self) -> int: ...
        kHasAll_CropEdge: ClassVar[ImageFilter.CropRect.CropEdge] = ...
        kHasHeight_CropEdge: ClassVar[ImageFilter.CropRect.CropEdge] = ...
        kHasLeft_CropEdge: ClassVar[ImageFilter.CropRect.CropEdge] = ...
        kHasTop_CropEdge: ClassVar[ImageFilter.CropRect.CropEdge] = ...
        kHasWidth_CropEdge: ClassVar[ImageFilter.CropRect.CropEdge] = ...
        @overload
        def __init__(self) -> None: ...
        @overload
        def __init__(self, rect: Rect, flags: int = ...) -> None: ...
        def applyTo(self, imageBounds: IRect, matrix: Matrix, embiggen: bool) -> IRect: ...
        def flags(self) -> int: ...
        def rect(self) -> Rect: ...

    class MapDirection:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        kForward_MapDirection: ClassVar[ImageFilter.MapDirection] = ...
        kReverse_MapDirection: ClassVar[ImageFilter.MapDirection] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    kForward_MapDirection: ClassVar[ImageFilter.MapDirection] = ...
    kReverse_MapDirection: ClassVar[ImageFilter.MapDirection] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def Deserialize(cls, data: buffer) -> ImageFilter: ...
    @classmethod
    def MakeMatrixFilter(cls, matrix: Matrix, quality: FilterQuality, input: ImageFilter = ...) -> ImageFilter: ...
    def asAColorFilter(self) -> object: ...
    def asColorFilter(self) -> object: ...
    def canComputeFastBounds(self) -> bool: ...
    def computeFastBounds(self, bounds: Rect) -> Rect: ...
    def countInputs(self) -> int: ...
    def filterBounds(self, src: IRect, ctm: Matrix, direction: ImageFilter.MapDirection, inputRect: IRect = ...) -> IRect: ...
    def getInput(self, i: int) -> ImageFilter: ...
    def isColorFilterNode(self) -> object: ...
    def makeWithLocalMatrix(self, matrix: Matrix) -> ImageFilter: ...

class ImageFilters:
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def AlphaThreshold(cls, region: Region, innerMin: float, outerMax: float, input: ImageFilter = ..., cropRect: IRect = ...) -> ImageFilter: ...
    @classmethod
    def Arithmetic(cls, k1: float, k2: float, k3: float, k4: float, enforcePMColor: bool, background: ImageFilter, foreground: ImageFilter = ..., cropRect: IRect = ...) -> ImageFilter: ...
    @classmethod
    def Blur(cls, sigmaX: float, sigmaY: float, tileMode: TileMode = ..., input: ImageFilter = ..., cropRect: IRect = ...) -> ImageFilter: ...
    @classmethod
    def ColorFilter(cls, cf: ColorFilter, input: ImageFilter = ..., cropRect: IRect = ...) -> ImageFilter: ...
    @classmethod
    def Compose(cls, outer: ImageFilter, inner: ImageFilter) -> ImageFilter: ...
    @classmethod
    def Dilate(cls, radiusX: float, radiusY: float, input: ImageFilter = ..., cropRect: IRect = ...) -> ImageFilter: ...
    @classmethod
    def DisplacementMap(cls, xChannelSelector: ColorChannel, yChannelSelector: ColorChannel, scale: float, displacement: ImageFilter, color: ImageFilter, cropRect: IRect = ...) -> ImageFilter: ...
    @classmethod
    def DistantLitDiffuse(cls, direction: Point3, lightColor: int, surfaceScale: float, kd: float, input: ImageFilter = ..., cropRect: IRect = ...) -> ImageFilter: ...
    @classmethod
    def DistantLitSpecular(cls, direction: Point3, lightColor: int, surfaceScale: float, ks: float, shininess: float, input: ImageFilter = ..., cropRect: IRect = ...) -> ImageFilter: ...
    @classmethod
    def DropShadow(cls, dx: float, dy: float, sigmaX: float, sigmaY: float, color: int, input: ImageFilter = ..., cropRect: IRect = ...) -> ImageFilter: ...
    @classmethod
    def DropShadowOnly(cls, dx: float, dy: float, sigmaX: float, sigmaY: float, color: int, input: ImageFilter = ..., cropRect: IRect = ...) -> ImageFilter: ...
    @classmethod
    def Erode(cls, radiusX: float, radiusY: float, input: ImageFilter = ..., cropRect: IRect = ...) -> ImageFilter: ...
    @overload
    @classmethod
    def Image(cls, image: Image, srcRect: Rect, dstRect: Rect, filterQuality: FilterQuality = ...) -> ImageFilter: ...
    @overload
    @classmethod
    def Image(cls, image: Image) -> ImageFilter: ...
    @classmethod
    def Magnifier(cls, srcRect: Rect, inset: float, input: ImageFilter = ..., cropRect: IRect = ...) -> ImageFilter: ...
    @classmethod
    def MatrixConvolution(cls, kernelSize: ISize, kernel: List[float], gain: float, bias: float, kernelOffset: IPoint, tileMode: TileMode, convolveAlpha: bool, input: ImageFilter = ..., cropRect: IRect = ...) -> ImageFilter: ...
    @classmethod
    def MatrixTransform(cls, matrix: Matrix, filterQuality: FilterQuality, input: ImageFilter = ...) -> ImageFilter: ...
    @classmethod
    def Merge(cls, filters: list, cropRect: IRect = ...) -> ImageFilter: ...
    @classmethod
    def Offset(cls, dx: float, dy: float, input: ImageFilter = ..., cropRect: IRect = ...) -> ImageFilter: ...
    @classmethod
    def Paint(cls, paint: Paint, cropRect: IRect = ...) -> ImageFilter: ...
    @classmethod
    def Picture(cls, pic: SkPicture, targetRect: Rect = ...) -> ImageFilter: ...
    @classmethod
    def PointLitDiffuse(cls, location: Point3, lightColor: int, surfaceScale: float, kd: float, input: ImageFilter = ..., cropRect: IRect = ...) -> ImageFilter: ...
    @classmethod
    def PointLitSpecular(cls, location: Point3, lightColor: int, surfaceScale: float, ks: float, shininess: float, input: ImageFilter = ..., cropRect: IRect = ...) -> ImageFilter: ...
    @classmethod
    def SpotLitDiffuse(cls, location: Point3, target: Point3, falloffExponent: float, cutoffAngle: float, lightColor: int, surfaceScale: float, kd: float, input: ImageFilter = ..., cropRect: IRect = ...) -> ImageFilter: ...
    @classmethod
    def SpotLitSpecular(cls, location: Point3, target: Point3, falloffExponent: float, cutoffAngle: float, lightColor: int, surfaceScale: float, ks: float, shininess: float, input: ImageFilter = ..., cropRect: IRect = ...) -> ImageFilter: ...
    @classmethod
    def Tile(cls, src: Rect, dst: Rect, input: ImageFilter = ...) -> ImageFilter: ...
    @classmethod
    def Xfermode(cls, mode: BlendMode, background: ImageFilter = ..., foreground: ImageFilter = ..., cropRect: IRect = ...) -> ImageFilter: ...

class ImageInfo:
    __hash__: ClassVar[None] = ...
    def __init__(self) -> None: ...
    @classmethod
    def ByteSizeOverflowed(cls, byteSize: int) -> bool: ...
    @overload
    @classmethod
    def Make(cls, width: int, height: int, ct: ColorType, at: AlphaType, cs: ColorSpace = ...) -> ImageInfo: ...
    @overload
    @classmethod
    def Make(cls, dimensions: ISize, ct: ColorType, at: AlphaType, cs: ColorSpace = ...) -> ImageInfo: ...
    @overload
    @classmethod
    def Make(cls, dimensions: ISize, colorInfo: ColorInfo) -> ImageInfo: ...
    @overload
    @classmethod
    def MakeA8(cls, width: int, height: int) -> ImageInfo: ...
    @overload
    @classmethod
    def MakeA8(cls, dimensions: ISize) -> ImageInfo: ...
    @classmethod
    def MakeN32(cls, width: int, height: int, at: AlphaType, cs: ColorSpace = ...) -> ImageInfo: ...
    @overload
    @classmethod
    def MakeN32Premul(cls, width: int, height: int, cs: ColorSpace = ...) -> ImageInfo: ...
    @overload
    @classmethod
    def MakeN32Premul(cls, dimensions: ISize, cs: ColorSpace = ...) -> ImageInfo: ...
    @classmethod
    def MakeS32(cls, width: int, height: int, at: AlphaType) -> ImageInfo: ...
    @overload
    @classmethod
    def MakeUnknown(cls, width: int, height: int) -> ImageInfo: ...
    @overload
    @classmethod
    def MakeUnknown(cls) -> ImageInfo: ...
    def alphaType(self) -> AlphaType: ...
    def bounds(self) -> IRect: ...
    def bytesPerPixel(self) -> int: ...
    def colorInfo(self) -> ColorInfo: ...
    def colorSpace(self) -> ColorSpace: ...
    def colorType(self) -> ColorType: ...
    def computeByteSize(self, rowBytes: int) -> int: ...
    def computeMinByteSize(self) -> int: ...
    def computeOffset(self, x: int, y: int, rowBytes: int) -> int: ...
    def dimensions(self) -> ISize: ...
    def gammaCloseToSRGB(self) -> bool: ...
    def height(self) -> int: ...
    def isEmpty(self) -> bool: ...
    def isOpaque(self) -> bool: ...
    def makeAlphaType(self, newAlphaType: AlphaType) -> ImageInfo: ...
    def makeColorSpace(self, cs: ColorSpace) -> ImageInfo: ...
    def makeColorType(self, newColorType: ColorType) -> ImageInfo: ...
    def makeDimensions(self, newSize: ISize) -> ImageInfo: ...
    def makeWH(self, newWidth: int, newHeight: int) -> ImageInfo: ...
    def minRowBytes(self) -> int: ...
    def minRowBytes64(self) -> int: ...
    def refColorSpace(self) -> ColorSpace: ...
    def reset(self) -> None: ...
    def shiftPerPixel(self) -> int: ...
    def validRowBytes(self, rowBytes: int) -> bool: ...
    def width(self) -> int: ...
    def __eq__(self, arg0: ImageInfo) -> bool: ...
    def __ne__(self, arg0: ImageInfo) -> bool: ...

class LightingImageFilter:
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def MakeDistantLitDiffuse(cls, direction: Point3, lightColor: int, surfaceScale: float, kd: float, input: ImageFilter = ..., cropRect: ImageFilter.CropRect = ...) -> ImageFilter: ...
    @classmethod
    def MakeDistantLitSpecular(cls, direction: Point3, lightColor: int, surfaceScale: float, ks: float, shininess: float, input: ImageFilter = ..., cropRect: ImageFilter.CropRect = ...) -> ImageFilter: ...
    @classmethod
    def MakePointLitDiffuse(cls, location: Point3, lightColor: int, surfaceScale: float, kd: float, input: ImageFilter = ..., cropRect: ImageFilter.CropRect = ...) -> ImageFilter: ...
    @classmethod
    def MakePointLitSpecular(cls, location: Point3, lightColor: int, surfaceScale: float, ks: float, shininess: float, input: ImageFilter = ..., cropRect: ImageFilter.CropRect = ...) -> ImageFilter: ...
    @classmethod
    def MakeSpotLitDiffuse(cls, location: Point3, target: Point3, falloffExponent: float, cutoffAngle: float, lightColor: int, surfaceScale: float, kd: float, input: ImageFilter = ..., cropRect: ImageFilter.CropRect = ...) -> ImageFilter: ...
    @classmethod
    def MakeSpotLitSpecular(cls, location: Point3, target: Point3, falloffExponent: float, cutoffAngle: float, lightColor: int, surfaceScale: float, ks: float, shininess: float, input: ImageFilter = ..., cropRect: ImageFilter.CropRect = ...) -> ImageFilter: ...

class Line2DPathEffect(PathEffect):
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def Make(cls, width: float, matrix: Matrix) -> PathEffect: ...

class LumaColorFilter:
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def Make(cls) -> ColorFilter: ...

class M44:
    def __init__(self) -> None: ...

class MagnifierImageFilter:
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def Make(cls, srcRect: Rect, inset: float, input: ImageFilter = ..., cropRect: ImageFilter.CropRect = ...) -> ImageFilter: ...

class MaskFilter(Flattanable):
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def Deserialize(cls, data: buffer) -> MaskFilter: ...
    @classmethod
    def MakeBlur(cls, style: BlurStyle, sigma: float, respectCTM: bool = ...) -> MaskFilter: ...

class Matrix:
    class ScaleToFit:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        kCenter_ScaleToFit: ClassVar[Matrix.ScaleToFit] = ...
        kEnd_ScaleToFit: ClassVar[Matrix.ScaleToFit] = ...
        kFill_ScaleToFit: ClassVar[Matrix.ScaleToFit] = ...
        kStart_ScaleToFit: ClassVar[Matrix.ScaleToFit] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class TypeMask:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        kAffine_Mask: ClassVar[Matrix.TypeMask] = ...
        kIdentity_Mask: ClassVar[Matrix.TypeMask] = ...
        kPerspective_Mask: ClassVar[Matrix.TypeMask] = ...
        kScale_Mask: ClassVar[Matrix.TypeMask] = ...
        kTranslate_Mask: ClassVar[Matrix.TypeMask] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    kAScaleX: ClassVar[int] = ...  # read-only
    kAScaleY: ClassVar[int] = ...  # read-only
    kASkewX: ClassVar[int] = ...  # read-only
    kASkewY: ClassVar[int] = ...  # read-only
    kATransX: ClassVar[int] = ...  # read-only
    kATransY: ClassVar[int] = ...  # read-only
    kMPersp0: ClassVar[int] = ...  # read-only
    kMPersp1: ClassVar[int] = ...  # read-only
    kMPersp2: ClassVar[int] = ...  # read-only
    kMScaleX: ClassVar[int] = ...  # read-only
    kMScaleY: ClassVar[int] = ...  # read-only
    kMSkewX: ClassVar[int] = ...  # read-only
    kMSkewY: ClassVar[int] = ...  # read-only
    kMTransX: ClassVar[int] = ...  # read-only
    kMTransY: ClassVar[int] = ...  # read-only
    kAffine_Mask: ClassVar[Matrix.TypeMask] = ...
    kCenter_ScaleToFit: ClassVar[Matrix.ScaleToFit] = ...
    kEnd_ScaleToFit: ClassVar[Matrix.ScaleToFit] = ...
    kFill_ScaleToFit: ClassVar[Matrix.ScaleToFit] = ...
    kIdentity_Mask: ClassVar[Matrix.TypeMask] = ...
    kPerspective_Mask: ClassVar[Matrix.TypeMask] = ...
    kScale_Mask: ClassVar[Matrix.TypeMask] = ...
    kStart_ScaleToFit: ClassVar[Matrix.ScaleToFit] = ...
    kTranslate_Mask: ClassVar[Matrix.TypeMask] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, array: numpy.ndarray[numpy.float32]) -> None: ...
    @classmethod
    def Concat(cls, *args, **kwargs) -> Any: ...
    @classmethod
    def I(cls) -> Matrix: ...
    @classmethod
    def InvalidMatrix(cls) -> Matrix: ...
    @classmethod
    def MakeAll(cls, scaleX: float, skewX: float, transX: float, skewY: float, scaleY: float, transY: float, pers0: float, pers1: float, pers2: float) -> Matrix: ...
    @classmethod
    def MakeRectToRect(cls, src: Rect, dst: Rect, stf: Matrix.ScaleToFit) -> Matrix: ...
    @overload
    @classmethod
    def RotateDeg(cls, deg: float) -> Matrix: ...
    @overload
    @classmethod
    def RotateDeg(cls, deg: float, pt: Point) -> Matrix: ...
    @classmethod
    def RotateRad(cls, rad: float) -> Matrix: ...
    @classmethod
    def Scale(cls, sx: float, sy: float) -> Matrix: ...
    @classmethod
    def SetAffineIdentity(cls) -> List[float]: ...
    @overload
    @classmethod
    def Translate(cls, dx: float, dy: float) -> Matrix: ...
    @overload
    @classmethod
    def Translate(cls, t: Point) -> Matrix: ...
    @overload
    @classmethod
    def Translate(cls, t: IPoint) -> Matrix: ...
    def asAffine(self) -> object: ...
    def decomposeScale(self, scale: Size, remaining: Matrix) -> bool: ...
    def dirtyMatrixTypeCache(self) -> None: ...
    def dump(self) -> None: ...
    def get(self, index: int) -> float: ...
    def get9(self) -> List[float]: ...
    def getMaxScale(self) -> float: ...
    def getMinMaxScales(self) -> tuple: ...
    def getMinScale(self) -> float: ...
    def getPerspX(self) -> float: ...
    def getPerspY(self) -> float: ...
    def getScaleX(self) -> float: ...
    def getScaleY(self) -> float: ...
    def getSkewX(self) -> float: ...
    def getSkewY(self) -> float: ...
    def getTranslateX(self) -> float: ...
    def getTranslateY(self) -> float: ...
    def getType(self) -> Matrix.TypeMask: ...
    def hasPerspective(self) -> bool: ...
    def invert(self, inverse: Matrix) -> bool: ...
    def isFinite(self) -> bool: ...
    def isIdentity(self) -> bool: ...
    def isScaleTranslate(self) -> bool: ...
    def isSimilarity(self, tol: float = ...) -> bool: ...
    def isTranslate(self) -> bool: ...
    def mapHomogeneousPoints(self, *args, **kwargs) -> Any: ...
    def mapPoints(self, *args, **kwargs) -> Any: ...
    def mapRadius(self, radius: float) -> float: ...
    def mapRect(self, src: Rect, pc: ApplyPerspectiveClip = ...) -> Rect: ...
    def mapRectScaleTranslate(self, src: Rect) -> Rect: ...
    def mapRectToQuad(self, *args, **kwargs) -> Any: ...
    def mapVector(self, *args, **kwargs) -> Any: ...
    def mapVectors(self, *args, **kwargs) -> Any: ...
    def mapXY(self, *args, **kwargs) -> Any: ...
    def normalizePerspective(self) -> None: ...
    def postConcat(self, *args, **kwargs) -> Any: ...
    def postRotate(self, *args, **kwargs) -> Any: ...
    def postScale(self, *args, **kwargs) -> Any: ...
    def postSkew(self, *args, **kwargs) -> Any: ...
    def postTranslate(self, *args, **kwargs) -> Any: ...
    def preConcat(self, *args, **kwargs) -> Any: ...
    def preRotate(self, *args, **kwargs) -> Any: ...
    def preScale(self, *args, **kwargs) -> Any: ...
    def preSkew(self, *args, **kwargs) -> Any: ...
    def preTranslate(self, *args, **kwargs) -> Any: ...
    def preservesAxisAlignment(self) -> bool: ...
    def preservesRightAngles(self, tol: float = ...) -> bool: ...
    def rc(self, r: int, c: int) -> float: ...
    def rectStaysRect(self) -> bool: ...
    def reset(self) -> Matrix: ...
    def set(self, index: int, value: float) -> None: ...
    def set9(self, buffer: List[float]) -> Matrix: ...
    def setAffine(self, affine: List[float]) -> Matrix: ...
    def setAll(self, scaleX: float, skewX: float, transX: float, skewY: float, scaleY: float, transY: float, persp0: float, persp1: float, persp2: float) -> Matrix: ...
    def setConcat(self, *args, **kwargs) -> Any: ...
    def setIdentity(self) -> Matrix: ...
    def setPerspX(self, v: float) -> Matrix: ...
    def setPerspY(self, v: float) -> Matrix: ...
    def setPolyToPoly(self, src: List[Point], dst: List[Point]) -> bool: ...
    def setRSXform(self, rsxForm: SkRSXform) -> Matrix: ...
    def setRectToRect(self, src: Rect, dst: Rect, stf: Matrix.ScaleToFit) -> bool: ...
    @overload
    def setRotate(self, degrees: float, px: float, py: float) -> Matrix: ...
    @overload
    def setRotate(self, degrees: float) -> Matrix: ...
    @overload
    def setScale(self, sx: float, sy: float, px: float, py: float) -> Matrix: ...
    @overload
    def setScale(self, sx: float, sy: float) -> Matrix: ...
    def setScaleTranslate(self, sx: float, sy: float, tx: float, ty: float) -> None: ...
    def setScaleX(self, v: float) -> Matrix: ...
    def setScaleY(self, v: float) -> Matrix: ...
    @overload
    def setSinCos(self, sinValue: float, cosValue: float, px: float, py: float) -> Matrix: ...
    @overload
    def setSinCos(self, sinValue: float, cosValue: float) -> Matrix: ...
    @overload
    def setSkew(self, kx: float, ky: float, px: float, py: float) -> Matrix: ...
    @overload
    def setSkew(self, kx: float, ky: float) -> Matrix: ...
    def setSkewX(self, v: float) -> Matrix: ...
    def setSkewY(self, v: float) -> Matrix: ...
    @overload
    def setTranslate(self, dx: float, dy: float) -> Matrix: ...
    @overload
    def setTranslate(self, v: Point) -> Matrix: ...
    def setTranslateX(self, v: float) -> Matrix: ...
    def setTranslateY(self, v: float) -> Matrix: ...
    def __getitem__(self, index: int) -> float: ...
    def __setitem__(self, index: int, value: float) -> None: ...

class MatrixPathEffect:
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def Make(cls, matrix: Matrix) -> PathEffect: ...
    @classmethod
    def MakeTranslate(cls, dx: float, dy: float) -> PathEffect: ...

class MemoryStream(StreamMemory):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, length: int) -> None: ...
    @overload
    def __init__(self, data: buffer, copyData: bool = ...) -> None: ...
    @overload
    def __init__(self, data: Data) -> None: ...
    @classmethod
    def Make(cls, data: Data) -> MemoryStream: ...
    @classmethod
    def MakeCopy(cls, data: buffer) -> MemoryStream: ...
    @classmethod
    def MakeDirect(cls, data: buffer) -> MemoryStream: ...
    def asData(self) -> Data: ...
    def getAtPos(self) -> capsule: ...
    def setData(self, data: Data) -> None: ...
    def setMemory(self, data: buffer, copyData: bool = ...) -> None: ...
    def skipToAlign4(self) -> None: ...

class MergePathEffect:
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def Make(cls, one: PathEffect, two: PathEffect, op: SkPathOp) -> PathEffect: ...

class MipmapBuilder:
    def __init__(self, arg0: ImageInfo) -> None: ...
    def attachTo(self, arg0: SkImage) -> SkImage: ...
    def countLevels(self) -> int: ...
    def level(self, arg0: int) -> SkPixmap: ...

class NullWStream(WStream):
    def __init__(self) -> None: ...

class OffsetImageFilter:
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def Make(cls, dx: float, dy: float, input: ImageFilter = ..., cropRect: ImageFilter.CropRect = ...) -> ImageFilter: ...

class OpBuilder:
    def __init__(self) -> None: ...
    def add(self, path: Path, op: PathOp) -> None: ...
    def resolve(self) -> Path: ...

class OverdrawColorFilter:
    kNumColors: ClassVar[int] = ...  # read-only
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def MakeWithColors(cls, colors: List[int]) -> ColorFilter: ...

class PDF:
    class AttributeList:
        def __init__(self) -> None: ...
        def appendFloat(self, owner: str, name: str, value: float) -> None: ...
        def appendFloatArray(self, owner: str, name: str, value: List[float]) -> None: ...
        def appendInt(self, owner: str, name: str, value: int) -> None: ...
        def appendString(self, owner: str, name: str, value: str) -> None: ...
        def appendStringArray(self, owner: str, name: str, value: List[String]) -> None: ...

    class DocumentStructureType:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        kAnnot: ClassVar[PDF.DocumentStructureType] = ...
        kArt: ClassVar[PDF.DocumentStructureType] = ...
        kBibEntry: ClassVar[PDF.DocumentStructureType] = ...
        kBlockQuote: ClassVar[PDF.DocumentStructureType] = ...
        kCaption: ClassVar[PDF.DocumentStructureType] = ...
        kCode: ClassVar[PDF.DocumentStructureType] = ...
        kDiv: ClassVar[PDF.DocumentStructureType] = ...
        kDocument: ClassVar[PDF.DocumentStructureType] = ...
        kFigure: ClassVar[PDF.DocumentStructureType] = ...
        kForm: ClassVar[PDF.DocumentStructureType] = ...
        kFormula: ClassVar[PDF.DocumentStructureType] = ...
        kH: ClassVar[PDF.DocumentStructureType] = ...
        kH1: ClassVar[PDF.DocumentStructureType] = ...
        kH2: ClassVar[PDF.DocumentStructureType] = ...
        kH3: ClassVar[PDF.DocumentStructureType] = ...
        kH4: ClassVar[PDF.DocumentStructureType] = ...
        kH5: ClassVar[PDF.DocumentStructureType] = ...
        kH6: ClassVar[PDF.DocumentStructureType] = ...
        kIndex: ClassVar[PDF.DocumentStructureType] = ...
        kL: ClassVar[PDF.DocumentStructureType] = ...
        kLBody: ClassVar[PDF.DocumentStructureType] = ...
        kLI: ClassVar[PDF.DocumentStructureType] = ...
        kLbl: ClassVar[PDF.DocumentStructureType] = ...
        kLink: ClassVar[PDF.DocumentStructureType] = ...
        kNonStruct: ClassVar[PDF.DocumentStructureType] = ...
        kNote: ClassVar[PDF.DocumentStructureType] = ...
        kP: ClassVar[PDF.DocumentStructureType] = ...
        kPart: ClassVar[PDF.DocumentStructureType] = ...
        kPrivate: ClassVar[PDF.DocumentStructureType] = ...
        kQuote: ClassVar[PDF.DocumentStructureType] = ...
        kRB: ClassVar[PDF.DocumentStructureType] = ...
        kRP: ClassVar[PDF.DocumentStructureType] = ...
        kRT: ClassVar[PDF.DocumentStructureType] = ...
        kReference: ClassVar[PDF.DocumentStructureType] = ...
        kRuby: ClassVar[PDF.DocumentStructureType] = ...
        kSect: ClassVar[PDF.DocumentStructureType] = ...
        kSpan: ClassVar[PDF.DocumentStructureType] = ...
        kTBody: ClassVar[PDF.DocumentStructureType] = ...
        kTD: ClassVar[PDF.DocumentStructureType] = ...
        kTFoot: ClassVar[PDF.DocumentStructureType] = ...
        kTH: ClassVar[PDF.DocumentStructureType] = ...
        kTHead: ClassVar[PDF.DocumentStructureType] = ...
        kTOC: ClassVar[PDF.DocumentStructureType] = ...
        kTOCI: ClassVar[PDF.DocumentStructureType] = ...
        kTR: ClassVar[PDF.DocumentStructureType] = ...
        kTable: ClassVar[PDF.DocumentStructureType] = ...
        kWP: ClassVar[PDF.DocumentStructureType] = ...
        kWT: ClassVar[PDF.DocumentStructureType] = ...
        kWarichu: ClassVar[PDF.DocumentStructureType] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class Metadata:
        fAuthor: String
        fCreator: String
        fEncodingQuality: int
        fKeywords: String
        fPDFA: bool
        fProducer: String
        fRasterDPI: float
        fStructureElementTreeRoot: PDF.StructureElementNode
        fSubject: String
        fTitle: String
        @overload
        def __init__(self) -> None: ...
        @overload
        def __init__(self, arg0: dict) -> None: ...

    class StructureElementNode:
        fAlt: String
        fLang: String
        fNodeId: int
        fTypeString: String
        def __init__(self) -> None: ...
        @property
        def fAdditionalNodeIds(self) -> List[int]: ...
        @property
        def fAttributes(self) -> PDF.AttributeList: ...
    kAnnot: ClassVar[PDF.DocumentStructureType] = ...
    kArt: ClassVar[PDF.DocumentStructureType] = ...
    kBibEntry: ClassVar[PDF.DocumentStructureType] = ...
    kBlockQuote: ClassVar[PDF.DocumentStructureType] = ...
    kCaption: ClassVar[PDF.DocumentStructureType] = ...
    kCode: ClassVar[PDF.DocumentStructureType] = ...
    kDiv: ClassVar[PDF.DocumentStructureType] = ...
    kDocument: ClassVar[PDF.DocumentStructureType] = ...
    kFigure: ClassVar[PDF.DocumentStructureType] = ...
    kForm: ClassVar[PDF.DocumentStructureType] = ...
    kFormula: ClassVar[PDF.DocumentStructureType] = ...
    kH: ClassVar[PDF.DocumentStructureType] = ...
    kH1: ClassVar[PDF.DocumentStructureType] = ...
    kH2: ClassVar[PDF.DocumentStructureType] = ...
    kH3: ClassVar[PDF.DocumentStructureType] = ...
    kH4: ClassVar[PDF.DocumentStructureType] = ...
    kH5: ClassVar[PDF.DocumentStructureType] = ...
    kH6: ClassVar[PDF.DocumentStructureType] = ...
    kIndex: ClassVar[PDF.DocumentStructureType] = ...
    kL: ClassVar[PDF.DocumentStructureType] = ...
    kLBody: ClassVar[PDF.DocumentStructureType] = ...
    kLI: ClassVar[PDF.DocumentStructureType] = ...
    kLbl: ClassVar[PDF.DocumentStructureType] = ...
    kLink: ClassVar[PDF.DocumentStructureType] = ...
    kNonStruct: ClassVar[PDF.DocumentStructureType] = ...
    kNote: ClassVar[PDF.DocumentStructureType] = ...
    kP: ClassVar[PDF.DocumentStructureType] = ...
    kPart: ClassVar[PDF.DocumentStructureType] = ...
    kPrivate: ClassVar[PDF.DocumentStructureType] = ...
    kQuote: ClassVar[PDF.DocumentStructureType] = ...
    kRB: ClassVar[PDF.DocumentStructureType] = ...
    kRP: ClassVar[PDF.DocumentStructureType] = ...
    kRT: ClassVar[PDF.DocumentStructureType] = ...
    kReference: ClassVar[PDF.DocumentStructureType] = ...
    kRuby: ClassVar[PDF.DocumentStructureType] = ...
    kSect: ClassVar[PDF.DocumentStructureType] = ...
    kSpan: ClassVar[PDF.DocumentStructureType] = ...
    kTBody: ClassVar[PDF.DocumentStructureType] = ...
    kTD: ClassVar[PDF.DocumentStructureType] = ...
    kTFoot: ClassVar[PDF.DocumentStructureType] = ...
    kTH: ClassVar[PDF.DocumentStructureType] = ...
    kTHead: ClassVar[PDF.DocumentStructureType] = ...
    kTOC: ClassVar[PDF.DocumentStructureType] = ...
    kTOCI: ClassVar[PDF.DocumentStructureType] = ...
    kTR: ClassVar[PDF.DocumentStructureType] = ...
    kTable: ClassVar[PDF.DocumentStructureType] = ...
    kWP: ClassVar[PDF.DocumentStructureType] = ...
    kWT: ClassVar[PDF.DocumentStructureType] = ...
    kWarichu: ClassVar[PDF.DocumentStructureType] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @overload
    @classmethod
    def MakeDocument(cls, stream: WStream, metadata: PDF.Metadata) -> Document: ...
    @overload
    @classmethod
    def MakeDocument(cls, stream: WStream) -> Document: ...
    @overload
    @classmethod
    def MakeDocument(cls, stream: WStream, **kwargs) -> Document: ...
    @classmethod
    def SetNodeId(cls, canvas: SkCanvas, nodeId: int) -> None: ...

class Paint:
    class Cap:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        kButt_Cap: ClassVar[Paint.Cap] = ...
        kDefault_Cap: ClassVar[Paint.Cap] = ...
        kLast_Cap: ClassVar[Paint.Cap] = ...
        kRound_Cap: ClassVar[Paint.Cap] = ...
        kSquare_Cap: ClassVar[Paint.Cap] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class Join:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        kBevel_Join: ClassVar[Paint.Join] = ...
        kDefault_Join: ClassVar[Paint.Join] = ...
        kLast_Join: ClassVar[Paint.Join] = ...
        kMiter_Join: ClassVar[Paint.Join] = ...
        kRound_Join: ClassVar[Paint.Join] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class Style:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        kFill_Style: ClassVar[Paint.Style] = ...
        kStrokeAndFill_Style: ClassVar[Paint.Style] = ...
        kStroke_Style: ClassVar[Paint.Style] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    kCapCount: ClassVar[int] = ...  # read-only
    kJoinCount: ClassVar[int] = ...  # read-only
    kStyleCount: ClassVar[int] = ...  # read-only
    kBevel_Join: ClassVar[Paint.Join] = ...
    kButt_Cap: ClassVar[Paint.Cap] = ...
    kDefault_Cap: ClassVar[Paint.Cap] = ...
    kDefault_Join: ClassVar[Paint.Join] = ...
    kFill_Style: ClassVar[Paint.Style] = ...
    kLast_Cap: ClassVar[Paint.Cap] = ...
    kLast_Join: ClassVar[Paint.Join] = ...
    kMiter_Join: ClassVar[Paint.Join] = ...
    kRound_Cap: ClassVar[Paint.Cap] = ...
    kRound_Join: ClassVar[Paint.Join] = ...
    kSquare_Cap: ClassVar[Paint.Cap] = ...
    kStrokeAndFill_Style: ClassVar[Paint.Style] = ...
    kStroke_Style: ClassVar[Paint.Style] = ...
    __hash__: ClassVar[None] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, color: Color4f, colorSpace: ColorSpace = ...) -> None: ...
    @overload
    def __init__(self, paint: Paint) -> None: ...
    @overload
    def __init__(self, **kwargs) -> None: ...
    @overload
    def __init__(self, d: dict) -> None: ...
    def canComputeFastBounds(self) -> bool: ...
    def computeFastBounds(self, orig: Rect) -> Rect: ...
    def computeFastStrokeBounds(self, orig: Rect) -> Rect: ...
    def doComputeFastBounds(self, orig: Rect, style: Paint.Style) -> Rect: ...
    def getAlpha(self) -> int: ...
    def getAlphaf(self) -> float: ...
    def getBlendMode(self) -> BlendMode: ...
    def getColor(self) -> int: ...
    def getColor4f(self) -> Color4f: ...
    def getColorFilter(self) -> SkColorFilter: ...
    def getFillPath(self, src: SkPath, dst: SkPath, cullRect: Rect = ..., resScale: float = ...) -> bool: ...
    def getFilterQuality(self) -> FilterQuality: ...
    def getHash(self) -> int: ...
    def getImageFilter(self) -> SkImageFilter: ...
    def getMaskFilter(self) -> SkMaskFilter: ...
    def getPathEffect(self) -> SkPathEffect: ...
    def getShader(self) -> SkShader: ...
    def getStrokeCap(self) -> Paint.Cap: ...
    def getStrokeJoin(self) -> Paint.Join: ...
    def getStrokeMiter(self) -> float: ...
    def getStrokeWidth(self) -> float: ...
    def getStyle(self) -> Paint.Style: ...
    def isAntiAlias(self) -> bool: ...
    def isDither(self) -> bool: ...
    def isSrcOver(self) -> bool: ...
    def nothingToDraw(self) -> bool: ...
    def refColorFilter(self) -> SkColorFilter: ...
    def refImageFilter(self) -> SkImageFilter: ...
    def refMaskFilter(self) -> SkMaskFilter: ...
    def refPathEffect(self) -> SkPathEffect: ...
    def refShader(self) -> SkShader: ...
    def reset(self) -> None: ...
    def setARGB(self, a: int, r: int, g: int, b: int) -> None: ...
    def setAlpha(self, a: int) -> None: ...
    def setAlphaf(self, a: float) -> None: ...
    def setAntiAlias(self, aa: bool) -> None: ...
    def setBlendMode(self, mode: BlendMode) -> None: ...
    def setColor(self, color: int) -> None: ...
    def setColor4f(self, color: Color4f, colorSpace: ColorSpace = ...) -> None: ...
    def setColorFilter(self, colorFilter: SkColorFilter) -> None: ...
    def setDither(self, dither: bool) -> None: ...
    def setFilterQuality(self, quality: FilterQuality) -> None: ...
    def setImageFilter(self, imageFilter: SkImageFilter) -> None: ...
    def setMaskFilter(self, maskFilter: SkMaskFilter) -> None: ...
    def setPathEffect(self, pathEffect: SkPathEffect) -> None: ...
    def setShader(self, shader: SkShader) -> None: ...
    def setStrokeCap(self, cap: Paint.Cap) -> None: ...
    def setStrokeJoin(self, join: Paint.Join) -> None: ...
    def setStrokeMiter(self, miter: float) -> None: ...
    def setStrokeWidth(self, width: float) -> None: ...
    def setStyle(self, style: Paint.Style) -> None: ...
    def __eq__(self, other: Paint) -> bool: ...
    def __ne__(self, other: Paint) -> bool: ...

class PaintImageFilter:
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def Make(cls, paint: Paint, cropRect: ImageFilter.CropRect = ...) -> ImageFilter: ...

class Path:
    class AddPathMode:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        kAppend_AddPathMode: ClassVar[Path.AddPathMode] = ...
        kExtend_AddPathMode: ClassVar[Path.AddPathMode] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class ArcSize:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        kLarge_ArcSize: ClassVar[Path.ArcSize] = ...
        kSmall_ArcSize: ClassVar[Path.ArcSize] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class Iter:
        @overload
        def __init__(self) -> None: ...
        @overload
        def __init__(self, path: Path, forceClose: bool) -> None: ...
        def conicWeight(self) -> float: ...
        def isCloseLine(self) -> bool: ...
        def isClosedContour(self) -> bool: ...
        def next(self) -> tuple: ...
        def setPath(self, path: Path, forceClose: bool) -> None: ...
        def __iter__(self) -> Path.Iter: ...
        def __next__(self) -> tuple: ...

    class RawIter:
        @overload
        def __init__(self) -> None: ...
        @overload
        def __init__(self, path: Path) -> None: ...
        def conicWeight(self) -> float: ...
        def next(self) -> tuple: ...
        def peek(self) -> Path.Verb: ...
        def setPath(self, path: Path) -> None: ...
        def __iter__(self) -> Path.RawIter: ...
        def __next__(self) -> tuple: ...

    class SegmentMask:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        kConic_SegmentMask: ClassVar[Path.SegmentMask] = ...
        kCubic_SegmentMask: ClassVar[Path.SegmentMask] = ...
        kLine_SegmentMask: ClassVar[Path.SegmentMask] = ...
        kQuad_SegmentMask: ClassVar[Path.SegmentMask] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class Verb:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        kClose_Verb: ClassVar[Path.Verb] = ...
        kConic_Verb: ClassVar[Path.Verb] = ...
        kCubic_Verb: ClassVar[Path.Verb] = ...
        kDone_Verb: ClassVar[Path.Verb] = ...
        kLine_Verb: ClassVar[Path.Verb] = ...
        kMove_Verb: ClassVar[Path.Verb] = ...
        kQuad_Verb: ClassVar[Path.Verb] = ...
        def __init__(self, value: int) -> None: ...
        def __and__(self, other: object) -> object: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> object: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: object) -> object: ...
        def __rand__(self, other: object) -> object: ...
        def __ror__(self, other: object) -> object: ...
        def __rxor__(self, other: object) -> object: ...
        def __setstate__(self, state: int) -> None: ...
        def __xor__(self, other: object) -> object: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    kAppend_AddPathMode: ClassVar[Path.AddPathMode] = ...
    kClose_Verb: ClassVar[Path.Verb] = ...
    kConic_SegmentMask: ClassVar[Path.SegmentMask] = ...
    kConic_Verb: ClassVar[Path.Verb] = ...
    kCubic_SegmentMask: ClassVar[Path.SegmentMask] = ...
    kCubic_Verb: ClassVar[Path.Verb] = ...
    kDone_Verb: ClassVar[Path.Verb] = ...
    kExtend_AddPathMode: ClassVar[Path.AddPathMode] = ...
    kLarge_ArcSize: ClassVar[Path.ArcSize] = ...
    kLine_SegmentMask: ClassVar[Path.SegmentMask] = ...
    kLine_Verb: ClassVar[Path.Verb] = ...
    kMove_Verb: ClassVar[Path.Verb] = ...
    kQuad_SegmentMask: ClassVar[Path.SegmentMask] = ...
    kQuad_Verb: ClassVar[Path.Verb] = ...
    kSmall_ArcSize: ClassVar[Path.ArcSize] = ...
    __hash__: ClassVar[None] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, path: Path) -> None: ...
    @classmethod
    def Circle(cls, center_x: float, center_y: float, radius: float, pathDirection: PathDirection = ...) -> Path: ...
    @classmethod
    def ConvertConicToQuads(cls, p0: Point, p1: Point, p2: Point, w: float, pow2: int) -> List[Point]: ...
    @classmethod
    def IsCubicDegenerate(cls, p1: Point, p2: Point, p3: Point, p4: Point, exact: bool) -> bool: ...
    @classmethod
    def IsLineDegenerate(cls, p1: Point, p2: Point, exact: bool) -> bool: ...
    @classmethod
    def IsQuadDegenerate(cls, p1: Point, p2: Point, p3: Point, exact: bool) -> bool: ...
    @classmethod
    def Line(cls, a: Point, b: Point) -> Path: ...
    @classmethod
    def Make(cls, points: List[Point], verbs: List[int], conicWeights: List[float], fillType: PathFillType, isVolatile: bool = ...) -> Path: ...
    @classmethod
    def Oval(cls, rect: Rect, pathDirection: PathDirection = ..., startIndex: int = ...) -> Path: ...
    @classmethod
    def Polygon(cls, points: List[Point], isClosed: bool, fillType: PathFillType = ..., isVolatile: bool = ...) -> Path: ...
    @overload
    @classmethod
    def RRect(cls, rrect: RRect, pathDirection: PathDirection = ..., startIndex: int = ...) -> Path: ...
    @overload
    @classmethod
    def RRect(cls, bounds: Rect, rx: float, ry: float, pathDirection: PathDirection = ...) -> Path: ...
    @classmethod
    def Rect(cls, rect: Rect, pathDirection: PathDirection = ..., startIndex: int = ...) -> Path: ...
    def addArc(self, oval: Rect, startAngle: float, sweepAngle: float) -> Path: ...
    def addCircle(self, x: float, y: float, radius: float, dir: PathDirection = ...) -> Path: ...
    @overload
    def addOval(self, oval: Rect, dir: PathDirection = ...) -> Path: ...
    @overload
    def addOval(self, oval: Rect, dir: PathDirection, start: int) -> Path: ...
    @overload
    def addPath(self, src: Path, dx: float, dy: float, mode: Path.AddPathMode = ...) -> Path: ...
    @overload
    def addPath(self, src: Path, mode: Path.AddPathMode = ...) -> Path: ...
    @overload
    def addPath(self, src: Path, matrix: Matrix, mode: Path.AddPathMode = ...) -> Path: ...
    def addPoly(self, pts: List[Point], close: bool) -> Path: ...
    @overload
    def addRRect(self, rrect: RRect, dir: PathDirection = ...) -> Path: ...
    @overload
    def addRRect(self, rrect: RRect, dir: PathDirection, start: int) -> Path: ...
    @overload
    def addRect(self, rect: Rect, dir: PathDirection = ...) -> Path: ...
    @overload
    def addRect(self, rect: Rect, dir: PathDirection, start: int) -> Path: ...
    @overload
    def addRect(self, left: float, top: float, right: float, bottom: float, dir: PathDirection = ...) -> Path: ...
    @overload
    def addRoundRect(self, rect: Rect, rx: float, ry: float, dir: PathDirection = ...) -> Path: ...
    @overload
    def addRoundRect(self, rect: Rect, radii: Iterable, dir: PathDirection = ...) -> Path: ...
    def approximateBytesUsed(self) -> int: ...
    @overload
    def arcTo(self, oval: Rect, startAngle: float, sweepAngle: float, forceMoveTo: bool) -> Path: ...
    @overload
    def arcTo(self, x1: float, y1: float, x2: float, y2: float, radius: float) -> Path: ...
    @overload
    def arcTo(self, p1: Point, p2: Point, radius: float) -> Path: ...
    @overload
    def arcTo(self, rx: float, ry: float, xAxisRotate: float, largeArc: Path.ArcSize, sweep: PathDirection, x: float, y: float) -> Path: ...
    @overload
    def arcTo(self, r: Point, xAxisRotate: float, largeArc: Path.ArcSize, sweep: PathDirection, xy: Point) -> Path: ...
    def close(self) -> Path: ...
    def computeTightBounds(self) -> Rect: ...
    @overload
    def conicTo(self, x1: float, y1: float, x2: float, y2: float, w: float) -> Path: ...
    @overload
    def conicTo(self, p1: Point, p2: Point, w: float) -> Path: ...
    def conservativelyContainsRect(self, rect: Rect) -> bool: ...
    def contains(self, x: float, y: float) -> bool: ...
    def countPoints(self) -> int: ...
    def countVerbs(self) -> int: ...
    @overload
    def cubicTo(self, x1: float, y1: float, x2: float, y2: float, x3: float, y3: float) -> Path: ...
    @overload
    def cubicTo(self, p1: Point, p2: Point, p3: Point) -> Path: ...
    @overload
    def dump(self, stream: WStream, forceClose: bool, dumpAsHex: bool) -> None: ...
    @overload
    def dump(self) -> None: ...
    def dumpHex(self) -> None: ...
    def getBounds(self) -> Rect: ...
    def getFillType(self) -> PathFillType: ...
    def getGenerationID(self) -> int: ...
    def getLastPt(self, lastPt: Point = ...) -> bool: ...
    def getPoint(self, index: int) -> Point: ...
    def getPoints(self, max: int = ...) -> List[Point]: ...
    def getSegmentMasks(self) -> int: ...
    def getVerbs(self, max: int = ...) -> List[Path.Verb]: ...
    def incReserve(self, extraPtCount: int) -> None: ...
    def interpolate(self, ending: Path, weight: float, out: Path) -> bool: ...
    def isConvex(self) -> bool: ...
    def isEmpty(self) -> bool: ...
    def isFinite(self) -> bool: ...
    def isInterpolatable(self, compare: Path) -> bool: ...
    def isInverseFillType(self) -> bool: ...
    def isLastContourClosed(self) -> bool: ...
    def isLine(self, p0: Point = ..., p1: Point = ...) -> bool: ...
    def isOval(self, oval: Rect = ...) -> bool: ...
    def isRRect(self, rrect: RRect = ...) -> bool: ...
    def isRect(self, rect: Rect = ..., isClosed: bool = ..., direction: PathDirection = ...) -> bool: ...
    def isValid(self) -> bool: ...
    def isVolatile(self) -> bool: ...
    @overload
    def lineTo(self, x: float, y: float) -> Path: ...
    @overload
    def lineTo(self) -> Any: ...
    @overload
    def lineTo(self) -> Any: ...
    @overload
    def lineTo(self, p: Point) -> Path: ...
    @overload
    def lineTo(self) -> Any: ...
    @overload
    def lineTo(self) -> Any: ...
    @overload
    def moveTo(self, x: float, y: float) -> Path: ...
    @overload
    def moveTo(self, p: Point) -> Path: ...
    def offset(self, dx: float, dy: float, dst: Path = ...) -> None: ...
    @overload
    def quadTo(self, x1: float, y1: float, x2: float, y2: float) -> Path: ...
    @overload
    def quadTo(self, p1: Point, p2: Point) -> Path: ...
    def rArcTo(self, rx: float, ry: float, xAxisRotate: float, largeArc: Path.ArcSize, sweep: PathDirection, dx: float, dy: float) -> Path: ...
    def rConicTo(self, dx1: float, dy1: float, dx2: float, dy2: float, w: float) -> Path: ...
    def rCubicTo(self, dx1: float, dy1: float, dx2: float, dy2: float, dx3: float, dy3: float) -> Path: ...
    def rLineTo(self, dx: float, dy: float) -> Path: ...
    def rMoveTo(self, dx: float, dy: float) -> Path: ...
    def rQuadTo(self, dx1: float, dy1: float, dx2: float, dy2: float) -> Path: ...
    def readFromMemory(self, buffer: buffer) -> int: ...
    def reset(self) -> Path: ...
    def reverseAddPath(self, src: Path) -> Path: ...
    def rewind(self) -> Path: ...
    def serialize(self) -> Data: ...
    def setFillType(self, ft: PathFillType) -> None: ...
    def setIsVolatile(self, isVolatile: bool) -> Path: ...
    @overload
    def setLastPt(self, x: float, y: float) -> None: ...
    @overload
    def setLastPt(self, p: Point) -> None: ...
    def shrinkToFit(self) -> None: ...
    def swap(self, other: Path) -> None: ...
    def toggleInverseFillType(self) -> None: ...
    def transform(self, matrix: Matrix, dst: Path = ..., pc: ApplyPerspectiveClip = ...) -> None: ...
    def updateBoundsCache(self) -> None: ...
    def writeToMemory(self) -> bytes: ...
    def __eq__(self, other: Path) -> bool: ...
    def __iter__(self) -> Path.Iter: ...
    def __ne__(self, other: Path) -> bool: ...

class Path1DPathEffect(PathEffect):
    class Style:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        kLastEnum_Style: ClassVar[Path1DPathEffect.Style] = ...
        kMorph_Style: ClassVar[Path1DPathEffect.Style] = ...
        kRotate_Style: ClassVar[Path1DPathEffect.Style] = ...
        kTranslate_Style: ClassVar[Path1DPathEffect.Style] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    kLastEnum_Style: ClassVar[Path1DPathEffect.Style] = ...
    kMorph_Style: ClassVar[Path1DPathEffect.Style] = ...
    kRotate_Style: ClassVar[Path1DPathEffect.Style] = ...
    kTranslate_Style: ClassVar[Path1DPathEffect.Style] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def Make(cls, path: SkPath, advance: float, phase: float, style: Path1DPathEffect.Style) -> PathEffect: ...

class Path2DPathEffect(PathEffect):
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def Make(cls, matrix: Matrix, path: SkPath) -> PathEffect: ...

class PathBuilder:
    class ArcSize:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        kLarge_ArcSize: ClassVar[PathBuilder.ArcSize] = ...
        kSmall_ArcSize: ClassVar[PathBuilder.ArcSize] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    kLarge_ArcSize: ClassVar[PathBuilder.ArcSize] = ...
    kSmall_ArcSize: ClassVar[PathBuilder.ArcSize] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, path: Path) -> None: ...
    def addArc(self, oval: Rect, startAngleDeg: float, sweepAngleDeg: float) -> PathBuilder: ...
    def addCircle(self, center_x: float, center_y: float, radius: float, pathDirection: PathDirection = ...) -> PathBuilder: ...
    @overload
    def addOval(self, rect: Rect, pathDirection: PathDirection, startIndex: int) -> PathBuilder: ...
    @overload
    def addOval(self, rect: Rect, pathDirection: PathDirection = ...) -> PathBuilder: ...
    def addPolygon(self, points: List[Point], isClosed: bool) -> PathBuilder: ...
    @overload
    def addRRect(self, rrect: RRect, pathDirection: PathDirection, startIndex: int) -> PathBuilder: ...
    @overload
    def addRRect(self, rrect: RRect, pathDirection: PathDirection = ...) -> PathBuilder: ...
    @overload
    def addRect(self, rect: Rect, pathDirection: PathDirection, startIndex: int) -> PathBuilder: ...
    @overload
    def addRect(self, rect: Rect, pathDirection: PathDirection = ...) -> PathBuilder: ...
    @overload
    def arcTo(self, oval: Rect, startAngleDeg: float, sweepAngleDeg: float, forceMoveTo: bool) -> PathBuilder: ...
    @overload
    def arcTo(self) -> Any: ...
    @overload
    def arcTo(self, p1: Point, p2: Point, radius: float) -> PathBuilder: ...
    @overload
    def arcTo(self) -> Any: ...
    @overload
    def arcTo(self) -> Any: ...
    @overload
    def arcTo(self) -> Any: ...
    @overload
    def arcTo(self, r: Point, xAxisRotate: float, largeArc: PathBuilder.ArcSize, sweep: PathDirection, xy: Point) -> PathBuilder: ...
    @overload
    def arcTo(self) -> Any: ...
    @overload
    def arcTo(self) -> Any: ...
    @overload
    def arcTo(self) -> Any: ...
    def close(self) -> PathBuilder: ...
    def computeBounds(self) -> Rect: ...
    @overload
    def conicTo(self, pt1: Point, pt2: Point, w: float) -> PathBuilder: ...
    @overload
    def conicTo(self, x1: float, y1: float, x2: float, y2: float, w: float) -> PathBuilder: ...
    @overload
    def conicTo(self, pts: List[Point], w: float) -> PathBuilder: ...
    @overload
    def cubicTo(self, pt1: Point, pt2: Point, pt3: Point) -> PathBuilder: ...
    @overload
    def cubicTo(self, x1: float, y1: float, x2: float, y2: float, x3: float, y3: float) -> PathBuilder: ...
    @overload
    def cubicTo(self, pts: List[Point]) -> PathBuilder: ...
    def detach(self) -> Path: ...
    def fillType(self) -> PathFillType: ...
    @overload
    def incReserve(self, extraPtCount: int, extraVerbCount: int) -> None: ...
    @overload
    def incReserve(self, extraPtCount: int) -> None: ...
    @overload
    def lineTo(self, pt: Point) -> PathBuilder: ...
    @overload
    def lineTo(self, x: float, y: float) -> PathBuilder: ...
    @overload
    def moveTo(self, pt: Point) -> PathBuilder: ...
    @overload
    def moveTo(self, x: float, y: float) -> PathBuilder: ...
    def offset(self, dx: float, dy: float) -> PathBuilder: ...
    def polylineTo(self, points: List[Point]) -> PathBuilder: ...
    @overload
    def quadTo(self, pt1: Point, pt2: Point) -> PathBuilder: ...
    @overload
    def quadTo(self, x1: float, y1: float, x2: float, y2: float) -> PathBuilder: ...
    @overload
    def quadTo(self, pts: List[Point]) -> PathBuilder: ...
    @overload
    def rConicTo(self, pt1: Point, pt2: Point, w: float) -> PathBuilder: ...
    @overload
    def rConicTo(self, x1: float, y1: float, x2: float, y2: float, w: float) -> PathBuilder: ...
    @overload
    def rCubicTo(self, pt1: Point, pt2: Point, pt3: Point) -> PathBuilder: ...
    @overload
    def rCubicTo(self, x1: float, y1: float, x2: float, y2: float, x3: float, y3: float) -> PathBuilder: ...
    @overload
    def rLineTo(self, pt: Point) -> PathBuilder: ...
    @overload
    def rLineTo(self, x: float, y: float) -> PathBuilder: ...
    @overload
    def rQuadTo(self, pt1: Point, pt2: Point) -> PathBuilder: ...
    @overload
    def rQuadTo(self, x1: float, y1: float, x2: float, y2: float) -> PathBuilder: ...
    def reset(self) -> PathBuilder: ...
    def setFillType(self, fillType: PathFillType) -> PathBuilder: ...
    def setIsVolatile(self, isVolatile: bool) -> PathBuilder: ...
    def snapshot(self) -> Path: ...
    def toggleInverseFillType(self) -> PathBuilder: ...

class PathDirection:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    kCCW: ClassVar[PathDirection] = ...
    kCW: ClassVar[PathDirection] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class PathEffect(Flattanable):
    class DashInfo:
        def __init__(self) -> None: ...
        @property
        def fCount(self) -> int: ...
        @property
        def fIntervals(self) -> List[float]: ...
        @property
        def fPhase(self) -> float: ...

    class DashType:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        kDash_DashType: ClassVar[PathEffect.DashType] = ...
        kNone_DashType: ClassVar[PathEffect.DashType] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class PointData:
        class PointFlags:
            __members__: ClassVar[dict] = ...  # read-only
            __entries: ClassVar[dict] = ...
            kCircles_PointFlag: ClassVar[PathEffect.PointData.PointFlags] = ...
            kUseClip_PointFlag: ClassVar[PathEffect.PointData.PointFlags] = ...
            kUsePath_PointFlag: ClassVar[PathEffect.PointData.PointFlags] = ...
            def __init__(self, value: int) -> None: ...
            def __and__(self, other: object) -> object: ...
            def __eq__(self, other: object) -> bool: ...
            def __ge__(self, other: object) -> bool: ...
            def __getstate__(self) -> int: ...
            def __gt__(self, other: object) -> bool: ...
            def __hash__(self) -> int: ...
            def __index__(self) -> int: ...
            def __int__(self) -> int: ...
            def __invert__(self) -> object: ...
            def __le__(self, other: object) -> bool: ...
            def __lt__(self, other: object) -> bool: ...
            def __ne__(self, other: object) -> bool: ...
            def __or__(self, other: object) -> object: ...
            def __rand__(self, other: object) -> object: ...
            def __ror__(self, other: object) -> object: ...
            def __rxor__(self, other: object) -> object: ...
            def __setstate__(self, state: int) -> None: ...
            def __xor__(self, other: object) -> object: ...
            @property
            def name(self) -> str: ...
            @property
            def value(self) -> int: ...
        kCircles_PointFlag: ClassVar[PathEffect.PointData.PointFlags] = ...
        kUseClip_PointFlag: ClassVar[PathEffect.PointData.PointFlags] = ...
        kUsePath_PointFlag: ClassVar[PathEffect.PointData.PointFlags] = ...
        def __init__(self) -> None: ...
        @property
        def fClipRect(self) -> Rect: ...
        @property
        def fFirst(self) -> SkPath: ...
        @property
        def fFlags(self) -> int: ...
        @property
        def fLast(self) -> SkPath: ...
        @property
        def fNumPoints(self) -> int: ...
        @property
        def fPath(self) -> SkPath: ...
        @property
        def fPoints(self) -> List[Point]: ...
        @property
        def fSize(self) -> Point: ...
    kDash_DashType: ClassVar[PathEffect.DashType] = ...
    kNone_DashType: ClassVar[PathEffect.DashType] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def Deserialize(cls, data: buffer) -> PathEffect: ...
    @classmethod
    def GetFlattenableType(cls) -> Flattanable.Type: ...
    @classmethod
    def MakeCompose(cls, outer: PathEffect, inner: PathEffect) -> PathEffect: ...
    @classmethod
    def MakeSum(cls, first: PathEffect, second: PathEffect) -> PathEffect: ...
    @classmethod
    def RegisterFlattenables(cls) -> None: ...
    def asADash(self, info: PathEffect.DashInfo) -> PathEffect.DashType: ...
    def asPoints(self, results: PathEffect.PointData, src: SkPath, stroke_rec: StrokeRec, matrix: Matrix, cullR: Rect) -> bool: ...
    def computeFastBounds(self, dst: Rect, src: Rect) -> None: ...
    def filterPath(self, *args, **kwargs) -> Any: ...

class PathFillType:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    kEvenOdd: ClassVar[PathFillType] = ...
    kInverseEvenOdd: ClassVar[PathFillType] = ...
    kInverseWinding: ClassVar[PathFillType] = ...
    kWinding: ClassVar[PathFillType] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class PathMeasure:
    class GetPosAndTan:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        kGetPosAndTan_MatrixFlag: ClassVar[PathMeasure.GetPosAndTan] = ...
        kGetPosition_MatrixFlag: ClassVar[PathMeasure.GetPosAndTan] = ...
        kGetTangent_MatrixFlag: ClassVar[PathMeasure.GetPosAndTan] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    kGetPosAndTan_MatrixFlag: ClassVar[PathMeasure.GetPosAndTan] = ...
    kGetPosition_MatrixFlag: ClassVar[PathMeasure.GetPosAndTan] = ...
    kGetTangent_MatrixFlag: ClassVar[PathMeasure.GetPosAndTan] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, path: Path, forceClosed: bool, resScale: float = ...) -> None: ...
    def getLength(self) -> float: ...
    def getMatrix(self, distance: float, flags: PathMeasure.GetPosAndTan = ...) -> object: ...
    def getPosTan(self, distance: float) -> object: ...
    def getSegment(self, startD: float, stopD: float, dst: Path, startWithMoveTo: bool) -> bool: ...
    def isClosed(self) -> bool: ...
    def nextContour(self) -> bool: ...
    def setPath(self, arg0: Path, arg1: bool) -> None: ...

class PathOp:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    kDifference_PathOp: ClassVar[PathOp] = ...
    kIntersect_PathOp: ClassVar[PathOp] = ...
    kReverseDifference_PathOp: ClassVar[PathOp] = ...
    kUnion_PathOp: ClassVar[PathOp] = ...
    kXOR_PathOp: ClassVar[PathOp] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class PathSegmentMask:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    kConic_PathSegmentMask: ClassVar[PathSegmentMask] = ...
    kCubic_PathSegmentMask: ClassVar[PathSegmentMask] = ...
    kLine_PathSegmentMask: ClassVar[PathSegmentMask] = ...
    kQuad_PathSegmentMask: ClassVar[PathSegmentMask] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class PathVerb:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    kClose: ClassVar[PathVerb] = ...
    kConic: ClassVar[PathVerb] = ...
    kCubic: ClassVar[PathVerb] = ...
    kLine: ClassVar[PathVerb] = ...
    kMove: ClassVar[PathVerb] = ...
    kQuad: ClassVar[PathVerb] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class PerlinNoiseShader:
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def MakeFractalNoise(cls, baseFrequencyX: float, baseFrequencyY: float, numOctaves: int, seed: float, tileSize: ISize = ...) -> Shader: ...
    @classmethod
    def MakeImprovedNoise(cls, baseFrequencyX: float, baseFrequencyY: float, numOctaves: int, z: float) -> Shader: ...
    @classmethod
    def MakeTurbulence(cls, baseFrequencyX: float, baseFrequencyY: float, numOctaves: int, seed: float, tileSize: ISize = ...) -> Shader: ...

class Picture(RefCnt):
    def __init__(self, cull: Rect) -> None: ...
    @classmethod
    def MakeFromData(cls, data: Data) -> Picture: ...
    @classmethod
    def MakeFromStream(cls, stream: Stream) -> Picture: ...
    @classmethod
    def MakePlaceholder(cls, cull: Rect) -> Picture: ...
    def approximateBytesUsed(self) -> int: ...
    def approximateOpCount(self, nested: bool = ...) -> int: ...
    def cullRect(self) -> Rect: ...
    def makeShader(self, tmx: TileMode, tmy: TileMode, localMatrix: Matrix = ..., tile: Rect = ...) -> Shader: ...
    def playback(self, canvas: SkCanvas) -> None: ...
    def serialize(self) -> Data: ...
    def uniqueID(self) -> int: ...

class PictureRecorder:
    class FinishFlags:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    def __init__(self) -> None: ...
    @overload
    def beginRecording(self, bounds: Rect) -> SkCanvas: ...
    @overload
    def beginRecording(self, width: float, height: float) -> SkCanvas: ...
    def finishRecordingAsDrawable(self) -> Drawable: ...
    def finishRecordingAsPicture(self) -> Picture: ...
    def finishRecordingAsPictureWithCull(self, cullRect: Rect) -> Picture: ...
    def getRecordingCanvas(self) -> SkCanvas: ...

class PixelGeometry:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    kBGR_H_PixelGeometry: ClassVar[PixelGeometry] = ...
    kBGR_V_PixelGeometry: ClassVar[PixelGeometry] = ...
    kRGB_H_PixelGeometry: ClassVar[PixelGeometry] = ...
    kRGB_V_PixelGeometry: ClassVar[PixelGeometry] = ...
    kUnknown_PixelGeometry: ClassVar[PixelGeometry] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class PixelRef:
    def __init__(self, *args, **kwargs) -> None: ...

class Pixmap:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, info: ImageInfo, data: object, rowBytes: int) -> None: ...
    @overload
    def __init__(self, array: numpy.ndarray, colorType: ColorType = ..., alphaType: AlphaType = ..., colorSpace: ColorSpace = ...) -> None: ...
    def addr(self) -> memoryview: ...
    def addr16(self) -> memoryview: ...
    def addr32(self) -> memoryview: ...
    def addr64(self) -> memoryview: ...
    def addr8(self) -> memoryview: ...
    def alphaType(self) -> AlphaType: ...
    def bounds(self) -> IRect: ...
    def colorSpace(self) -> ColorSpace: ...
    def colorType(self) -> ColorType: ...
    def computeByteSize(self) -> int: ...
    def computeIsOpaque(self) -> bool: ...
    def dimensions(self) -> ISize: ...
    def erase(self, color: Color4f, subset: IRect = ...) -> bool: ...
    def extractSubset(self, subset: Pixmap, area: IRect) -> bool: ...
    def getAlphaf(self, x: int, y: int) -> float: ...
    def getColor(self, x: int, y: int) -> int: ...
    def height(self) -> int: ...
    def info(self) -> ImageInfo: ...
    def isOpaque(self) -> bool: ...
    @overload
    def readPixels(self, dstInfo: ImageInfo, dstPixels: buffer, dstRowBytes: int = ..., srcX: int = ..., srcY: int = ...) -> bool: ...
    @overload
    def readPixels(self, dst: Pixmap, srcX: int = ..., srcY: int = ...) -> bool: ...
    def refColorSpace(self) -> ColorSpace: ...
    @overload
    def reset(self) -> None: ...
    @overload
    def reset(self, info: ImageInfo, data: object, rowBytes: int) -> None: ...
    def rowBytes(self) -> int: ...
    def rowBytesAsPixels(self) -> int: ...
    def scalePixels(self, dst: Pixmap, filterQuality: FilterQuality = ...) -> bool: ...
    def setColorSpace(self, colorSpace: ColorSpace) -> None: ...
    def shiftPerPixel(self) -> int: ...
    def tobytes(self) -> object: ...
    def width(self) -> int: ...
    def writable_addr(self) -> memoryview: ...
    def __getitem__(self, arg0: object) -> int: ...
    def __len__(self) -> int: ...
    @property
    def __array_interface__(self) -> dict: ...

class Point:
    __hash__: ClassVar[None] = ...
    fX: float
    fY: float
    @overload
    def __init__(self, x: float, y: float) -> None: ...
    @overload
    def __init__(self, ipoint: IPoint) -> None: ...
    @overload
    def __init__(self, t: tuple) -> None: ...
    @classmethod
    def CrossProduct(cls, a: Point, b: Point) -> float: ...
    @classmethod
    def Distance(cls, a: Point, b: Point) -> float: ...
    @classmethod
    def DotProduct(cls, a: Point, b: Point) -> float: ...
    @classmethod
    def Length(cls, x: float, y: float) -> float: ...
    @classmethod
    def Make(cls, x: float, y: float) -> Point: ...
    @classmethod
    def Normalize(cls, vec: Point) -> float: ...
    @classmethod
    def Offset(cls, *args, **kwargs) -> Any: ...
    def cross(self, vec: Point) -> float: ...
    def distanceToOrigin(self) -> float: ...
    def dot(self, vec: Point) -> float: ...
    @overload
    def equals(self, x: float, y: float) -> bool: ...
    @overload
    def equals(self, x, y) -> Any: ...
    def isFinite(self) -> bool: ...
    def isZero(self) -> bool: ...
    @overload
    def iset(self, x: int, y: int) -> None: ...
    @overload
    def iset(self, p: IPoint) -> None: ...
    def length(self) -> float: ...
    def negate(self) -> None: ...
    def normalize(self) -> bool: ...
    @overload
    def offset(self, dx: float, dy: float) -> None: ...
    @overload
    def offset(self, dx, dy) -> Any: ...
    def scale(self, scale: float) -> Point: ...
    def set(self, x: float, y: float) -> None: ...
    def setAbs(self, pt: Point) -> None: ...
    @overload
    def setLength(self, length: float) -> bool: ...
    @overload
    def setLength(self, x: float, y: float, length: float) -> bool: ...
    def setNormalize(self, x: float, y: float) -> bool: ...
    def x(self) -> float: ...
    def y(self) -> float: ...
    def __add__(self, other: Point) -> Point: ...
    def __eq__(self, other: Point) -> bool: ...
    def __iadd__(self, v: Point) -> Point: ...
    def __imul__(self, scale: float) -> Point: ...
    def __isub__(self, v: Point) -> Point: ...
    def __iter__(self) -> Iterator: ...
    def __len__(self) -> int: ...
    def __mul__(self, scale: float) -> Point: ...
    def __ne__(self, other: Point) -> bool: ...
    def __neg__(self) -> Point: ...
    def __sub__(self, other: Point) -> Point: ...

class Point3:
    __hash__: ClassVar[None] = ...
    fX: float
    fY: float
    fZ: float
    @overload
    def __init__(self, x: float, y: float, z: float) -> None: ...
    @overload
    def __init__(self, t: tuple) -> None: ...
    @classmethod
    def CrossProduct(cls, a: Point3, b: Point3) -> Point3: ...
    @classmethod
    def DotProduct(cls, a: Point3, b: Point3) -> float: ...
    @classmethod
    def Length(cls, x: float, y: float, z: float) -> float: ...
    @classmethod
    def Make(cls, x: float, y: float, z: float) -> Point3: ...
    def cross(self, vec: Point3) -> Point3: ...
    def dot(self, vec: Point3) -> float: ...
    def isFinite(self) -> bool: ...
    def length(self) -> float: ...
    def makeScale(self, scale: float) -> Point3: ...
    def normalize(self) -> bool: ...
    def scale(self, scale: float) -> None: ...
    def set(self, x: float, y: float, z: float) -> None: ...
    def x(self) -> float: ...
    def y(self) -> float: ...
    def z(self) -> float: ...
    def __add__(self, other: Point3) -> Point3: ...
    def __eq__(self, other: Point3) -> bool: ...
    def __iadd__(self, v: Point3) -> Point3: ...
    def __isub__(self, v: Point3) -> Point3: ...
    def __iter__(self) -> Iterator: ...
    def __len__(self) -> int: ...
    def __ne__(self, other: Point3) -> bool: ...
    def __neg__(self) -> Point3: ...
    def __rmul__(self, scale: float) -> Point3: ...
    def __sub__(self, other: Point3) -> Point3: ...

class RRect:
    class Corner:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        kLowerLeft_Corner: ClassVar[RRect.Corner] = ...
        kLowerRight_Corner: ClassVar[RRect.Corner] = ...
        kUpperLeft_Corner: ClassVar[RRect.Corner] = ...
        kUpperRight_Corner: ClassVar[RRect.Corner] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class Type:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        kComplex_Type: ClassVar[RRect.Type] = ...
        kEmpty_Type: ClassVar[RRect.Type] = ...
        kLastType: ClassVar[RRect.Type] = ...
        kNinePatch_Type: ClassVar[RRect.Type] = ...
        kOval_Type: ClassVar[RRect.Type] = ...
        kRect_Type: ClassVar[RRect.Type] = ...
        kSimple_Type: ClassVar[RRect.Type] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    kSizeInMemory: ClassVar[int] = ...  # read-only
    kComplex_Type: ClassVar[RRect.Type] = ...
    kEmpty_Type: ClassVar[RRect.Type] = ...
    kLastType: ClassVar[RRect.Type] = ...
    kLowerLeft_Corner: ClassVar[RRect.Corner] = ...
    kLowerRight_Corner: ClassVar[RRect.Corner] = ...
    kNinePatch_Type: ClassVar[RRect.Type] = ...
    kOval_Type: ClassVar[RRect.Type] = ...
    kRect_Type: ClassVar[RRect.Type] = ...
    kSimple_Type: ClassVar[RRect.Type] = ...
    kUpperLeft_Corner: ClassVar[RRect.Corner] = ...
    kUpperRight_Corner: ClassVar[RRect.Corner] = ...
    __hash__: ClassVar[None] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, rrect: RRect) -> None: ...
    @overload
    def __init__(self, rect: Rect, xRad: float, yRad: float) -> None: ...
    @classmethod
    def MakeEmpty(cls) -> RRect: ...
    @classmethod
    def MakeOval(cls, oval: Rect) -> RRect: ...
    @classmethod
    def MakeRect(cls, r: Rect) -> RRect: ...
    @classmethod
    def MakeRectXY(cls, rect: Rect, xRad: float, yRad: float) -> RRect: ...
    def contains(self, rect: Rect) -> bool: ...
    def dump(self, asHex: bool = ...) -> None: ...
    def dumpHex(self) -> None: ...
    def dumpToString(self, asHex: bool) -> SkString: ...
    def getBounds(self) -> Rect: ...
    def getSimpleRadii(self) -> Point: ...
    def getType(self) -> RRect.Type: ...
    def height(self) -> float: ...
    @overload
    def inset(self, dx: float, dy: float, dst: RRect) -> None: ...
    @overload
    def inset(self, dx: float, dy: float) -> None: ...
    def isComplex(self) -> bool: ...
    def isEmpty(self) -> bool: ...
    def isNinePatch(self) -> bool: ...
    def isOval(self) -> bool: ...
    def isRect(self) -> bool: ...
    def isSimple(self) -> bool: ...
    def isValid(self) -> bool: ...
    def makeOffset(self, dx: float, dy: float) -> RRect: ...
    def offset(self, dx: float, dy: float) -> None: ...
    @overload
    def outset(self, dx: float, dy: float, dst: RRect) -> None: ...
    @overload
    def outset(self, dx: float, dy: float) -> None: ...
    def radii(self, corner: RRect.Corner) -> Point: ...
    def readFromMemory(self, buffer: str) -> int: ...
    def rect(self) -> Rect: ...
    def setEmpty(self) -> None: ...
    def setNinePatch(self, rect: Rect, leftRad: float, topRad: float, rightRad: float, bottomRad: float) -> None: ...
    def setOval(self, oval: Rect) -> None: ...
    def setRect(self, rect: Rect) -> None: ...
    def setRectRadii(self, rect: Rect, radii: List[Point]) -> None: ...
    def setRectXY(self, rect: Rect, xRad: float, yRad: float) -> None: ...
    def transform(self, matrix: SkMatrix, dst: RRect) -> bool: ...
    def type(self) -> RRect.Type: ...
    def width(self) -> float: ...
    def writeToMemory(self) -> bytes: ...
    def __eq__(self, other: RRect) -> bool: ...
    def __ne__(self, other: RRect) -> bool: ...

class RSXform:
    fSCos: float
    fSSin: float
    fTx: float
    fTy: float
    def __init__(self, scos: float, ssin: float, tx: float, ty: float) -> None: ...
    @classmethod
    def Make(cls, scos: float, ssin: float, tx: float, ty: float) -> RSXform: ...
    @classmethod
    def MakeFromRadians(cls, scale: float, radians: float, tx: float, ty: float, ax: float, ay: float) -> RSXform: ...
    def rectStaysRect(self) -> bool: ...
    def set(self, scos: float, ssin: float, tx: float, ty: float) -> None: ...
    def setIdentity(self) -> None: ...
    @overload
    def toQuad(self, width: float, height: float, quqd: Point) -> None: ...
    @overload
    def toQuad(self, size: Size, quqd: Point) -> None: ...
    def toTriStrip(self, width: float, height: float, strip: Point) -> None: ...

class Rect:
    __hash__: ClassVar[None] = ...
    fBottom: float
    fLeft: float
    fRight: float
    fTop: float
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, w: float, h: float) -> None: ...
    @overload
    def __init__(self, l: float, t: float, r: float, b: float) -> None: ...
    @overload
    def __init__(self, size: ISize) -> None: ...
    @overload
    def __init__(self, irect: IRect) -> None: ...
    @overload
    def __init__(self, t: tuple) -> None: ...
    @classmethod
    def Intersects(cls, a: Rect, b: Rect) -> bool: ...
    @overload
    @classmethod
    def Make(cls, size: ISize) -> Rect: ...
    @overload
    @classmethod
    def Make(cls, irect: IRect) -> Rect: ...
    @classmethod
    def MakeEmpty(cls) -> Rect: ...
    @classmethod
    def MakeIWH(cls, w: int, h: int) -> Rect: ...
    @classmethod
    def MakeLTRB(cls, l: float, t: float, r: float, b: float) -> Rect: ...
    @classmethod
    def MakeSize(cls, size: Size) -> Rect: ...
    @classmethod
    def MakeWH(cls, w: float, h: float) -> Rect: ...
    @classmethod
    def MakeXYWH(cls, x: float, y: float, w: float, h: float) -> Rect: ...
    def asScalars(self) -> memoryview: ...
    def bottom(self) -> float: ...
    def centerX(self) -> float: ...
    def centerY(self) -> float: ...
    @overload
    def contains(self, x: float, y: float) -> bool: ...
    @overload
    def contains(self, r: Rect) -> bool: ...
    @overload
    def contains(self, r: IRect) -> bool: ...
    def dump(self, asHex: bool = ...) -> None: ...
    def dumpHex(self) -> None: ...
    def height(self) -> float: ...
    def inset(self, dx: float, dy: float) -> None: ...
    @overload
    def intersect(self, r: Rect) -> bool: ...
    @overload
    def intersect(self, a: Rect, b: Rect) -> bool: ...
    def intersects(self, r: Rect) -> bool: ...
    def isEmpty(self) -> bool: ...
    def isFinite(self) -> bool: ...
    def isSorted(self) -> bool: ...
    def join(self, r: Rect) -> None: ...
    def joinNonEmptyArg(self, r: Rect) -> None: ...
    def joinPossiblyEmptyRect(self, r: Rect) -> None: ...
    def left(self) -> float: ...
    def makeInset(self, dx: float, dy: float) -> Rect: ...
    @overload
    def makeOffset(self, dx: float, dy: float) -> Rect: ...
    @overload
    def makeOffset(self, v: Point) -> Rect: ...
    def makeOutset(self, dx: float, dy: float) -> Rect: ...
    def makeSorted(self) -> Rect: ...
    @overload
    def offset(self, dx: float, dy: float) -> None: ...
    @overload
    def offset(self, delta: Point) -> None: ...
    def offsetTo(self, newX: float, newY: float) -> None: ...
    def outset(self, dx: float, dy: float) -> None: ...
    def right(self) -> float: ...
    def round(self) -> IRect: ...
    def roundIn(self) -> IRect: ...
    def roundOut(self) -> IRect: ...
    @overload
    def set(self, src: IRect) -> None: ...
    @overload
    def set(self, p0: Point, p1: Point) -> None: ...
    def setBounds(self, points: List[Point]) -> None: ...
    def setBoundsCheck(self, points: List[Point]) -> bool: ...
    def setBoundsNoCheck(self, points: List[Point]) -> None: ...
    def setEmpty(self) -> None: ...
    def setIWH(self, width: int, height: int) -> None: ...
    def setLTRB(self, left: float, top: float, right: float, bottom: float) -> None: ...
    def setWH(self, width: float, height: float) -> None: ...
    def setXYWH(self, x: float, y: float, width: float, height: float) -> None: ...
    def sort(self) -> None: ...
    def toQuad(self) -> List[Point]: ...
    def top(self) -> float: ...
    def width(self) -> float: ...
    def x(self) -> float: ...
    def y(self) -> float: ...
    @overload
    def __contains__(self, arg0: Point) -> bool: ...
    @overload
    def __contains__(self, arg0: Rect) -> bool: ...
    @overload
    def __contains__(self, arg0: IRect) -> bool: ...
    def __eq__(self, other: Rect) -> bool: ...
    def __iter__(self) -> Iterator: ...
    def __len__(self) -> int: ...
    def __ne__(self, other: Rect) -> bool: ...

class RefCnt(RefCntBase):
    def __init__(self, *args, **kwargs) -> None: ...

class RefCntBase:
    def __init__(self, *args, **kwargs) -> None: ...
    def ref(self) -> None: ...
    def unique(self) -> bool: ...
    def unref(self) -> None: ...

class Region:
    class Cliperator:
        def __init__(self, region: Region, clip: IRect) -> None: ...
        def done(self) -> bool: ...
        def next(self) -> None: ...
        def rect(self) -> IRect: ...
        def __iter__(self) -> Region.Cliperator: ...
        def __next__(self) -> IRect: ...

    class Iterator:
        @overload
        def __init__(self) -> None: ...
        @overload
        def __init__(self, region: Region) -> None: ...
        def done(self) -> bool: ...
        def next(self) -> None: ...
        def rect(self) -> IRect: ...
        def reset(self, region: Region) -> None: ...
        def rewind(self) -> bool: ...
        def rgn(self) -> Region: ...
        def __iter__(self) -> Region.Iterator: ...
        def __next__(self) -> IRect: ...

    class Op:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        kDifference_Op: ClassVar[Region.Op] = ...
        kIntersect_Op: ClassVar[Region.Op] = ...
        kLastOp: ClassVar[Region.Op] = ...
        kReplace_Op: ClassVar[Region.Op] = ...
        kReverseDifference_Op: ClassVar[Region.Op] = ...
        kUnion_Op: ClassVar[Region.Op] = ...
        kXOR_Op: ClassVar[Region.Op] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class Spanerator:
        def __init__(self, region: Region, y: int, left: int, right: int) -> None: ...
        def next(self, left: int, right: int) -> bool: ...
        def __iter__(self) -> Region.Spanerator: ...
        def __next__(self) -> tuple: ...
    kOpCnt: ClassVar[int] = ...  # read-only
    kDifference_Op: ClassVar[Region.Op] = ...
    kIntersect_Op: ClassVar[Region.Op] = ...
    kLastOp: ClassVar[Region.Op] = ...
    kReplace_Op: ClassVar[Region.Op] = ...
    kReverseDifference_Op: ClassVar[Region.Op] = ...
    kUnion_Op: ClassVar[Region.Op] = ...
    kXOR_Op: ClassVar[Region.Op] = ...
    __hash__: ClassVar[None] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, region: Region) -> None: ...
    @overload
    def __init__(self, rect: IRect) -> None: ...
    def cliperator(self, clip: IRect) -> Region.Cliperator: ...
    def computeRegionComplexity(self) -> int: ...
    @overload
    def contains(self, x: int, y: int) -> bool: ...
    @overload
    def contains(self, other: IRect) -> bool: ...
    @overload
    def contains(self, other: Region) -> bool: ...
    def getBoundaryPath(self, path: SkPath) -> bool: ...
    def getBounds(self) -> IRect: ...
    @overload
    def intersects(self, rect: IRect) -> bool: ...
    @overload
    def intersects(self, other: Region) -> bool: ...
    def isComplex(self) -> bool: ...
    def isEmpty(self) -> bool: ...
    def isRect(self) -> bool: ...
    @overload
    def iterator(self) -> Region.Iterator: ...
    @overload
    def iterator(self) -> Any: ...
    @overload
    def op(self, rect: IRect, op: Region.Op) -> bool: ...
    @overload
    def op(self, region: Region, op: Region.Op) -> bool: ...
    @overload
    def op(self, rect: IRect, region: Region, op: Region.Op) -> bool: ...
    @overload
    def op(self, region: Region, rect: IRect, op: Region.Op) -> bool: ...
    @overload
    def op(self, regionA: Region, regionB: Region, op: Region.Op) -> bool: ...
    def quickContains(self, r: IRect) -> bool: ...
    @overload
    def quickReject(self, rect: IRect) -> bool: ...
    @overload
    def quickReject(self, region: Region) -> bool: ...
    def readFromMemory(self, data: SkData) -> int: ...
    def set(self, src: Region) -> bool: ...
    def setEmpty(self) -> bool: ...
    def setPath(self, path: SkPath, clip: Region) -> bool: ...
    def setRect(self, rect: IRect) -> bool: ...
    def setRects(self, rects: List[IRect]) -> bool: ...
    def setRegion(self, region: Region) -> bool: ...
    def spanerator(self, y: int, left: int, right: int) -> Region.Spanerator: ...
    @overload
    def swap(self, other: Region) -> None: ...
    @overload
    def swap(self) -> Any: ...
    @overload
    def swap(self) -> Any: ...
    def translate(self, dx: int, dy: int) -> Region: ...
    def writeToMemory(self) -> SkData: ...
    @overload
    def __and__(self, arg0: Region) -> Region: ...
    @overload
    def __and__(self, arg0: IRect) -> Region: ...
    def __eq__(self, other: Region) -> bool: ...
    @overload
    def __iand__(self, arg0: Region) -> Region: ...
    @overload
    def __iand__(self, arg0: IRect) -> Region: ...
    @overload
    def __ior__(self, arg0: Region) -> Region: ...
    @overload
    def __ior__(self, arg0: IRect) -> Region: ...
    @overload
    def __isub__(self, arg0: Region) -> Region: ...
    @overload
    def __isub__(self, arg0: IRect) -> Region: ...
    def __iter__(self) -> Region.Iterator: ...
    @overload
    def __ixor__(self, arg0: Region) -> Region: ...
    @overload
    def __ixor__(self, arg0: IRect) -> Region: ...
    def __ne__(self, other: Region) -> bool: ...
    @overload
    def __or__(self, arg0: Region) -> Region: ...
    @overload
    def __or__(self, arg0: IRect) -> Region: ...
    @overload
    def __sub__(self, arg0: Region) -> Region: ...
    @overload
    def __sub__(self, arg0: IRect) -> Region: ...
    @overload
    def __xor__(self, arg0: Region) -> Region: ...
    @overload
    def __xor__(self, arg0: IRect) -> Region: ...

class SVGCanvas:
    kConvertTextToPaths_Flag: ClassVar[int] = ...  # read-only
    kNoPrettyXML_Flag: ClassVar[int] = ...  # read-only
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def Make(cls, bounds: Rect, stream: WStream, flags: int = ...) -> Canvas: ...

class SVGDOM(RefCnt):
    def __init__(self) -> None: ...
    @classmethod
    def MakeFromStream(cls, stream: Stream) -> SVGDOM: ...
    def containerSize(self) -> Size: ...
    def render(self, arg0: Canvas) -> None: ...
    def setContainerSize(self, arg0: Size) -> None: ...

class Shader(Flattanable):
    class GradientInfo:
        fColorCount: int
        def __init__(self) -> None: ...
        @property
        def fColorOffsets(self) -> List[int]: ...
        @property
        def fColors(self) -> List[int]: ...
        @property
        def fGradientFlags(self) -> int: ...
        @property
        def fPoint(self) -> tuple: ...
        @property
        def fRadius(self) -> tuple: ...
        @property
        def fTileMode(self) -> TileMode: ...

    class GradientType:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        kColor_GradientType: ClassVar[Shader.GradientType] = ...
        kConical_GradientType: ClassVar[Shader.GradientType] = ...
        kLast_GradientType: ClassVar[Shader.GradientType] = ...
        kLinear_GradientType: ClassVar[Shader.GradientType] = ...
        kNone_GradientType: ClassVar[Shader.GradientType] = ...
        kRadial_GradientType: ClassVar[Shader.GradientType] = ...
        kSweep_GradientType: ClassVar[Shader.GradientType] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    kColor_GradientType: ClassVar[Shader.GradientType] = ...
    kConical_GradientType: ClassVar[Shader.GradientType] = ...
    kLast_GradientType: ClassVar[Shader.GradientType] = ...
    kLinear_GradientType: ClassVar[Shader.GradientType] = ...
    kNone_GradientType: ClassVar[Shader.GradientType] = ...
    kRadial_GradientType: ClassVar[Shader.GradientType] = ...
    kSweep_GradientType: ClassVar[Shader.GradientType] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def Deserialize(cls, data: buffer) -> Shader: ...
    def asAGradient(self, info: Shader.GradientInfo) -> Shader.GradientType: ...
    @overload
    def isAImage(self, localMatrix: Matrix, xy: List[TileMode] = ...) -> Image: ...
    @overload
    def isAImage(self) -> bool: ...
    def isOpaque(self) -> bool: ...
    def makeWithColorFilter(self, colorFilter: ColorFilter) -> Shader: ...
    def makeWithLocalMatrix(self, matrix: Matrix) -> Shader: ...

class ShaderMaskFilter:
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def Make(cls, shader: Shader) -> MaskFilter: ...

class Shaders:
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def Blend(cls, mode: BlendMode, dst: Shader, src: Shader) -> Shader: ...
    @overload
    @classmethod
    def Color(cls, color: int) -> Shader: ...
    @overload
    @classmethod
    def Color(cls, color: Color4f, cs: ColorSpace = ...) -> Shader: ...
    @classmethod
    def Empty(cls) -> Shader: ...
    @classmethod
    def Lerp(cls, t: float, dst: Shader, src: Shader) -> Shader: ...

class Size:
    __hash__: ClassVar[None] = ...
    fHeight: float
    fWidth: float
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, width: float, height: float) -> None: ...
    @overload
    def __init__(self, isize: ISize) -> None: ...
    @overload
    def __init__(self, t: tuple) -> None: ...
    @overload
    @classmethod
    def Make(cls, width: float, height: float) -> Size: ...
    @overload
    @classmethod
    def Make(cls, isize: ISize) -> Size: ...
    @classmethod
    def MakeEmpty(cls) -> Size: ...
    def equals(self, width: float, height: float) -> bool: ...
    def height(self) -> float: ...
    def isEmpty(self) -> bool: ...
    def isZero(self) -> bool: ...
    def set(self, width: float, height: float) -> None: ...
    def setEmpty(self) -> None: ...
    def toCeil(self) -> ISize: ...
    def toFloor(self) -> ISize: ...
    def toRound(self) -> ISize: ...
    def width(self) -> float: ...
    def __eq__(self, other: Size) -> bool: ...
    def __iter__(self) -> Iterator: ...
    def __len__(self) -> int: ...
    def __ne__(self, other: Size) -> bool: ...

class Stream:
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def MakeFromFile(cls, path: str) -> SkStreamAsset: ...
    def duplicate(self) -> Stream: ...
    def fork(self) -> Stream: ...
    def getLength(self) -> int: ...
    def getMemoryBase(self) -> capsule: ...
    def getPosition(self) -> int: ...
    def hasLength(self) -> bool: ...
    def hasPosition(self) -> bool: ...
    def isAtEnd(self) -> bool: ...
    def move(self, offset: int) -> bool: ...
    def peek(self, buffer: buffer) -> int: ...
    def read(self, buffer: buffer, size: int = ...) -> int: ...
    def readBool(self) -> bool: ...
    def readPackedUInt(self) -> int: ...
    def readS16(self) -> int: ...
    def readS32(self) -> int: ...
    def readS8(self) -> int: ...
    def readScalar(self) -> float: ...
    def readU16(self) -> int: ...
    def readU32(self) -> int: ...
    def readU8(self) -> int: ...
    def rewind(self) -> bool: ...
    def seek(self, position: int) -> bool: ...
    def skip(self, size: int) -> int: ...

class StreamAsset(StreamSeekable):
    def __init__(self, *args, **kwargs) -> None: ...
    def duplicate(self) -> StreamSeekable: ...
    def fork(self) -> StreamSeekable: ...

class StreamMemory(StreamAsset):
    def __init__(self, *args, **kwargs) -> None: ...
    def duplicate(self) -> StreamSeekable: ...
    def fork(self) -> StreamSeekable: ...

class StreamRewindable(Stream):
    def __init__(self, *args, **kwargs) -> None: ...
    def duplicate(self) -> StreamRewindable: ...

class StreamSeekable(StreamRewindable):
    def __init__(self, *args, **kwargs) -> None: ...
    def fork(self) -> StreamSeekable: ...

class String:
    __hash__: ClassVar[None] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, size: int) -> None: ...
    @overload
    def __init__(self, text: str) -> None: ...
    @overload
    def __init__(self, text: str) -> None: ...
    @overload
    def __init__(self, text: str, size: int) -> None: ...
    @overload
    def __init__(self, other: String) -> None: ...
    @overload
    def append(self, str: String) -> None: ...
    @overload
    def append(self, text: str) -> None: ...
    @overload
    def append(self, text: str, size: int) -> None: ...
    def appendHex(self, value: int, minDigits: int = ...) -> None: ...
    def appendS32(self, value: int) -> None: ...
    def appendS64(self, value: int, minDigits: int = ...) -> None: ...
    def appendScalar(self, value: float) -> None: ...
    def appendU32(self, value: int) -> None: ...
    def appendU64(self, value: int, minDigits: int = ...) -> None: ...
    def appendUnichar(self, value: int) -> None: ...
    def c_str(self) -> str: ...
    @overload
    def contains(self, subStr: str) -> bool: ...
    @overload
    def contains(self, subChar: str) -> bool: ...
    @overload
    def endsWith(self, suffixStr: str) -> bool: ...
    @overload
    def endsWith(self, suffixChar: str) -> bool: ...
    @overload
    def equals(self, text: String) -> bool: ...
    @overload
    def equals(self, text: str) -> bool: ...
    @overload
    def equals(self, text: str, size: int) -> bool: ...
    def find(self, substring: str) -> int: ...
    def findLastOf(self, subchar: str) -> int: ...
    @overload
    def insert(self, offset: int, src: String) -> None: ...
    @overload
    def insert(self, offset: int, text: str) -> None: ...
    @overload
    def insert(self, offset: int, text: str, size: int) -> None: ...
    def insertHex(self, offset: int, value: int, minDigits: int = ...) -> None: ...
    def insertS32(self, offset: int, value: int) -> None: ...
    def insertS64(self, offset: int, value: int, minDigits: int = ...) -> None: ...
    def insertScalar(self, offset: int, value: float) -> None: ...
    def insertU32(self, offset: int, value: int) -> None: ...
    def insertU64(self, offset: int, value: int, minDigits: int = ...) -> None: ...
    def insertUnichar(self, offset: int, value: int) -> None: ...
    def isEmpty(self) -> bool: ...
    @overload
    def prepend(self, str: String) -> None: ...
    @overload
    def prepend(self, text: str) -> None: ...
    @overload
    def prepend(self, text: str, size: int) -> None: ...
    def prependHex(self, value: int, minDigits: int = ...) -> None: ...
    def prependS32(self, value: int) -> None: ...
    def prependS64(self, value: int, minDigits: int = ...) -> None: ...
    def prependScalar(self, value: float) -> None: ...
    def prependUnichar(self, value: int) -> None: ...
    def remove(self, offset: int, size: int) -> None: ...
    def reset(self) -> None: ...
    def resize(self, size: int) -> None: ...
    @overload
    def set(self, src: String) -> None: ...
    @overload
    def set(self, text: str) -> None: ...
    @overload
    def set(self, text: str, size: int) -> None: ...
    def size(self) -> int: ...
    @overload
    def startsWith(self, prefixStr: str) -> bool: ...
    @overload
    def startsWith(self, prefixChar: str) -> bool: ...
    def swap(self, other: String) -> None: ...
    def __contains__(self, subStr: str) -> bool: ...
    def __eq__(self, text: String) -> bool: ...
    def __getitem__(self, arg0: int) -> str: ...
    @overload
    def __iadd__(self, other: String) -> String: ...
    @overload
    def __iadd__(self, other: str) -> String: ...
    @overload
    def __iadd__(self, other: str) -> String: ...
    def __len__(self) -> int: ...
    def __setitem__(self, arg0: int, arg1: str) -> String: ...

class StrokePathEffect:
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def Make(cls, width: float, join: Paint.Join, cap: Paint.Cap, miter: float = ...) -> PathEffect: ...

class StrokeRec:
    class InitStyle:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        kFill_InitStyle: ClassVar[StrokeRec.InitStyle] = ...
        kHairline_InitStyle: ClassVar[StrokeRec.InitStyle] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class Style:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        kFill_Style: ClassVar[StrokeRec.Style] = ...
        kHairline_Style: ClassVar[StrokeRec.Style] = ...
        kStrokeAndFill_Style: ClassVar[StrokeRec.Style] = ...
        kStroke_Style: ClassVar[StrokeRec.Style] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    kStyleCount: ClassVar[int] = ...  # read-only
    kFill_InitStyle: ClassVar[StrokeRec.InitStyle] = ...
    kFill_Style: ClassVar[StrokeRec.Style] = ...
    kHairline_InitStyle: ClassVar[StrokeRec.InitStyle] = ...
    kHairline_Style: ClassVar[StrokeRec.Style] = ...
    kStrokeAndFill_Style: ClassVar[StrokeRec.Style] = ...
    kStroke_Style: ClassVar[StrokeRec.Style] = ...
    @overload
    def __init__(self, style: StrokeRec.InitStyle) -> None: ...
    @overload
    def __init__(self, paint: Paint, style: Paint.Style, resScale: float = ...) -> None: ...
    @overload
    def __init__(self, paint: Paint, resScale: float = ...) -> None: ...
    @overload
    @classmethod
    def GetInflationRadius(cls, paint: Paint, style: Paint.Style) -> float: ...
    @overload
    @classmethod
    def GetInflationRadius(cls, join: Paint.Join, miterLimit: float, cap: Paint.Cap, strokeWidth: float) -> float: ...
    def applyToPaint(self, paint: Paint) -> None: ...
    def applyToPath(self, dst: SkPath, src: SkPath) -> bool: ...
    def getCap(self) -> Paint.Cap: ...
    def getInflationRadius(self) -> float: ...
    def getJoin(self) -> Paint.Join: ...
    def getMiter(self) -> float: ...
    def getResScale(self) -> float: ...
    def getStyle(self) -> StrokeRec.Style: ...
    def getWidth(self) -> float: ...
    def hasEqualEffect(self, other: StrokeRec) -> bool: ...
    def isFillStyle(self) -> bool: ...
    def isHairlineStyle(self) -> bool: ...
    def needToApply(self) -> bool: ...
    def setFillStyle(self) -> None: ...
    def setHairlineStyle(self) -> None: ...
    def setResScale(self, rs: float) -> None: ...
    def setStrokeParams(self, cap: Paint.Cap, join: Paint.Join, miterLimit: float) -> None: ...
    def setStrokeStyle(self, width: float, strokeAndFill: bool = ...) -> None: ...

class Surface(RefCnt):
    class AsyncReadResult:
        def __init__(self, *args, **kwargs) -> None: ...
        def count(self) -> int: ...
        def data(self, i: int) -> capsule: ...
        def rowBytes(self, i: int) -> int: ...

    class BackendHandleAccess:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        kDiscardWrite_BackendHandleAccess: ClassVar[Surface.BackendHandleAccess] = ...
        kFlushRead_BackendHandleAccess: ClassVar[Surface.BackendHandleAccess] = ...
        kFlushWrite_BackendHandleAccess: ClassVar[Surface.BackendHandleAccess] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class BackendSurfaceAccess:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        kNoAccess: ClassVar[Surface.BackendSurfaceAccess] = ...
        kPresent: ClassVar[Surface.BackendSurfaceAccess] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class ContentChangeMode:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        kDiscard_ContentChangeMode: ClassVar[Surface.ContentChangeMode] = ...
        kRetain_ContentChangeMode: ClassVar[Surface.ContentChangeMode] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class RescaleGamma:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        kLinear: ClassVar[Surface.RescaleGamma] = ...
        kSrc: ClassVar[Surface.RescaleGamma] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    kDiscardWrite_BackendHandleAccess: ClassVar[Surface.BackendHandleAccess] = ...
    kDiscard_ContentChangeMode: ClassVar[Surface.ContentChangeMode] = ...
    kFlushRead_BackendHandleAccess: ClassVar[Surface.BackendHandleAccess] = ...
    kFlushWrite_BackendHandleAccess: ClassVar[Surface.BackendHandleAccess] = ...
    kLinear: ClassVar[Surface.RescaleGamma] = ...
    kNoAccess: ClassVar[Surface.BackendSurfaceAccess] = ...
    kPresent: ClassVar[Surface.BackendSurfaceAccess] = ...
    kRetain_ContentChangeMode: ClassVar[Surface.ContentChangeMode] = ...
    kSrc: ClassVar[Surface.RescaleGamma] = ...
    @overload
    def __init__(self, width: int, height: int, surfaceProps: SurfaceProps = ...) -> None: ...
    @overload
    def __init__(self, array: numpy.ndarray, colorType: ColorType = ..., alphaType: AlphaType = ..., colorSpace: ColorSpace = ..., surfaceProps: SurfaceProps = ...) -> None: ...
    @classmethod
    def MakeFromBackendRenderTarget(cls, context: GrContext, backendRenderTarget: GrBackendRenderTarget, origin: GrSurfaceOrigin, colorType: ColorType, colorSpace: ColorSpace, surfaceProps: SurfaceProps = ...) -> Surface: ...
    @classmethod
    def MakeFromBackendTexture(cls, context: GrContext, backendTexture: GrBackendTexture, origin: GrSurfaceOrigin, sampleCnt: int, colorType: ColorType, colorSpace: ColorSpace, surfaceProps: SurfaceProps) -> Surface: ...
    @classmethod
    def MakeNull(cls, width: int, height: int) -> Surface: ...
    @classmethod
    def MakeRaster(cls, imageInfo: ImageInfo, rowBytes: int = ..., surfaceProps: SurfaceProps = ...) -> Surface: ...
    @classmethod
    def MakeRasterDirect(cls, info: ImageInfo, pixels: buffer, rowBytes: int = ..., surfaceProps: SurfaceProps = ...) -> Surface: ...
    @classmethod
    def MakeRasterN32Premul(cls, width: int, height: int, surfaceProps: SurfaceProps = ...) -> Surface: ...
    @overload
    @classmethod
    def MakeRenderTarget(cls, context: GrRecordingContext, budgeted: Budgeted, imageInfo: ImageInfo, sampleCount: int = ..., surfaceOrigin: GrSurfaceOrigin = ..., surfaceProps: SurfaceProps = ..., shouldCreateWithMips: bool = ...) -> Surface: ...
    @overload
    @classmethod
    def MakeRenderTarget(cls, context: GrRecordingContext, budgeted: Budgeted, imageInfo: ImageInfo, sampleCount: int, surfaceProps: SurfaceProps) -> Surface: ...
    @overload
    @classmethod
    def MakeRenderTarget(cls, context: GrRecordingContext, budgeted: Budgeted, imageInfo: ImageInfo) -> Surface: ...
    @overload
    @classmethod
    def MakeRenderTarget(cls, context: GrRecordingContext, characterization: SurfaceCharacterization, budgeted: Budgeted) -> Surface: ...
    def asyncRescaleAndReadPixels(self, info: ImageInfo, srcRect: IRect, rescaleGamma: Surface.RescaleGamma, rescaleQuality: FilterQuality, callback: function) -> None: ...
    def asyncRescaleAndReadPixelsYUV420(self, yuvColorSpace: YUVColorSpace, dstColorSpace: ColorSpace, srcRect: IRect, dstSize: ISize, rescaleGamma: Surface.RescaleGamma, rescaleQuality: FilterQuality, callback: function) -> None: ...
    def characterize(self, characterization: SurfaceCharacterization) -> bool: ...
    @overload
    def draw(self, canvas: Canvas, x: float, y: float, paint: Paint = ...) -> None: ...
    @overload
    def draw(self, deferredDisplayList: SkDeferredDisplayList) -> bool: ...
    @overload
    def flush(self, access: Surface.BackendSurfaceAccess, info: GrFlushInfo) -> GrSemaphoresSubmitted: ...
    @overload
    def flush(self, info: GrFlushInfo, newState: GrBackendSurfaceMutableState = ...) -> GrSemaphoresSubmitted: ...
    def flushAndSubmit(self) -> None: ...
    def generationID(self) -> int: ...
    def getBackendRenderTarget(self, backendHandleAccess: Surface.BackendHandleAccess) -> GrBackendRenderTarget: ...
    def getBackendTexture(self, backendHandleAccess: Surface.BackendHandleAccess) -> GrBackendTexture: ...
    def getCanvas(self) -> Canvas: ...
    def height(self) -> int: ...
    def imageInfo(self) -> ImageInfo: ...
    def isCompatible(self, characterization: SurfaceCharacterization) -> bool: ...
    @overload
    def makeImageSnapshot(self) -> Image: ...
    @overload
    def makeImageSnapshot(self, bounds: IRect) -> Image: ...
    @overload
    def makeSurface(self, imageInfo: ImageInfo) -> Surface: ...
    @overload
    def makeSurface(self, width: int, height: int) -> Surface: ...
    @overload
    def makeSurface(self) -> Any: ...
    def notifyContentWillChange(self, mode: Surface.ContentChangeMode) -> None: ...
    def peekPixels(self, pixmap: Pixmap) -> bool: ...
    def props(self) -> SurfaceProps: ...
    @overload
    def readPixels(self, dst: Pixmap, srcX: int = ..., srcY: int = ...) -> bool: ...
    @overload
    def readPixels(self, dstInfo: ImageInfo, dstPixels: buffer, dstRowBytes: int = ..., srcX: int = ..., srcY: int = ...) -> bool: ...
    @overload
    def readPixels(self, dst: Bitmap, srcX: int, srcY: int) -> bool: ...
    def recordingContext(self) -> GrRecordingContext: ...
    def replaceBackendTexture(self, backendTexture: GrBackendTexture, origin: GrSurfaceOrigin, mode: Surface.ContentChangeMode = ...) -> bool: ...
    def toarray(self, srcX: int = ..., srcY: int = ..., colorType: ColorType = ..., alphaType: AlphaType = ..., colorSpace: ColorSpace = ...) -> numpy.ndarray: ...
    def width(self) -> int: ...
    @overload
    def writePixels(self, src: Pixmap, dstX: int = ..., dstY: int = ...) -> None: ...
    @overload
    def writePixels(self, src: Bitmap, dstX: int = ..., dstY: int = ...) -> None: ...
    def __enter__(self) -> Canvas: ...
    def __exit__(self, arg0: object, arg1: object, arg2: object) -> None: ...

class SurfaceCharacterization:
    __hash__: ClassVar[None] = ...
    def __init__(self) -> None: ...
    def cacheMaxResourceBytes(self) -> int: ...
    def colorSpace(self) -> ColorSpace: ...
    def createBackendFormat(self, colorType: ColorType, backendFormat: GrBackendFormat) -> SurfaceCharacterization: ...
    def createColorSpace(self, cs: ColorSpace) -> SurfaceCharacterization: ...
    def createFBO0(self, usesGLFBO0: bool) -> SurfaceCharacterization: ...
    def createResized(self, width: int, height: int) -> SurfaceCharacterization: ...
    def height(self) -> int: ...
    def isMipMapped(self) -> bool: ...
    def isTextureable(self) -> bool: ...
    def isValid(self) -> bool: ...
    def refColorSpace(self) -> ColorSpace: ...
    def surfaceProps(self) -> SurfaceProps: ...
    def usesGLFBO0(self) -> bool: ...
    def vulkanSecondaryCBCompatible(self) -> bool: ...
    def width(self) -> int: ...
    def __eq__(self, arg0: SurfaceCharacterization) -> bool: ...
    def __ne__(self, arg0: SurfaceCharacterization) -> bool: ...

class SurfaceProps:
    class Flags:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        kUseDeviceIndependentFonts_Flag: ClassVar[SurfaceProps.Flags] = ...
        def __init__(self, value: int) -> None: ...
        def __and__(self, other: object) -> object: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __gt__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> object: ...
        def __le__(self, other: object) -> bool: ...
        def __lt__(self, other: object) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: object) -> object: ...
        def __rand__(self, other: object) -> object: ...
        def __ror__(self, other: object) -> object: ...
        def __rxor__(self, other: object) -> object: ...
        def __setstate__(self, state: int) -> None: ...
        def __xor__(self, other: object) -> object: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class InitType:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        kLegacyFontHost_InitType: ClassVar[SurfaceProps.InitType] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    kUseDistanceFieldFonts_Flag: ClassVar[SurfaceProps.Flags] = ...  # read-only
    kLegacyFontHost_InitType: ClassVar[SurfaceProps.InitType] = ...
    kUseDeviceIndependentFonts_Flag: ClassVar[SurfaceProps.Flags] = ...
    __hash__: ClassVar[None] = ...
    @overload
    def __init__(self, flags: int, geometry: PixelGeometry) -> None: ...
    @overload
    def __init__(self, initType: SurfaceProps.InitType) -> None: ...
    @overload
    def __init__(self, flags: int, initType: SurfaceProps.InitType) -> None: ...
    @overload
    def __init__(self, props: SurfaceProps) -> None: ...
    def flags(self) -> int: ...
    def isUseDeviceIndependentFonts(self) -> bool: ...
    def pixelGeometry(self) -> PixelGeometry: ...
    def __eq__(self, arg0: SurfaceProps) -> bool: ...
    def __ne__(self, arg0: SurfaceProps) -> bool: ...

class TableColorFilter:
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def Make(cls, table: List[int]) -> ColorFilter: ...
    @classmethod
    def MakeARGB(cls, tableA: object, tableR: object, tableG: object, tableB: object) -> ColorFilter: ...

class TableMaskFilter:
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def Create(cls, table: List[int]) -> MaskFilter: ...
    @classmethod
    def CreateClip(cls, min: int, max: int) -> MaskFilter: ...
    @classmethod
    def CreateGamma(cls, gamma: float) -> MaskFilter: ...
    @classmethod
    def MakeClipTable(cls, min: int, max: int) -> object: ...
    @classmethod
    def MakeGammaTable(cls, gamma: float) -> object: ...

class TextBlob:
    class Iter:
        class Run:
            def __init__(self) -> None: ...
            @property
            def fGlyphCount(self) -> int: ...
            @property
            def fGlyphIndices(self) -> List[int]: ...
            @property
            def fTypeface(self) -> Typeface: ...
        def __init__(self, arg0: TextBlob) -> None: ...
        def next(self, run: TextBlob.Iter.Run) -> bool: ...
        def __next__(self) -> TextBlob.Iter.Run: ...
    def __init__(self, text: str, font: Font, positions: object = ..., encoding: TextEncoding = ...) -> None: ...
    @classmethod
    def Deserialize(cls, data: buffer) -> TextBlob: ...
    @classmethod
    def MakeFromPosText(cls, text: str, pos: List[Point], font: Font, encoding: TextEncoding = ...) -> TextBlob: ...
    @classmethod
    def MakeFromPosTextH(cls, text: str, xpos: Iterable, constY: float, font: Font, encoding: TextEncoding = ...) -> TextBlob: ...
    @classmethod
    def MakeFromRSXform(cls, text: str, xform: List[RSXform], font: Font, encoding: TextEncoding = ...) -> TextBlob: ...
    @classmethod
    def MakeFromString(cls, string: str, font: Font, encoding: TextEncoding = ...) -> TextBlob: ...
    @classmethod
    def MakeFromText(cls, text: str, font: Font, encoding: TextEncoding = ...) -> TextBlob: ...
    def bounds(self) -> Rect: ...
    def deref(self) -> None: ...
    def getIntercepts(self, bounds: Iterable, paint: Paint = ...) -> List[float]: ...
    def ref(self) -> None: ...
    def refCntGreaterThan(self, count: int) -> bool: ...
    def serialize(self) -> Data: ...
    def unique(self) -> bool: ...
    def uniqueID(self) -> int: ...
    def unref(self) -> None: ...
    def __iter__(self) -> TextBlob.Iter: ...

class TextBlobBuilder:
    def __init__(self) -> None: ...
    def allocRun(self, text: str, font: Font, x: float, y: float, bounds: Rect = ..., encoding: TextEncoding = ...) -> None: ...
    def allocRunPos(self, font: Font, glyphs: List[int], positions: Iterable, bounds: Rect = ...) -> None: ...
    def allocRunPosH(self, font: Font, glyphs: List[int], xpos: Iterable, y: float, bounds: Rect = ...) -> None: ...
    def allocRunRSXform(self, font: Font, glyphs: List[int], xforms: List[RSXform]) -> None: ...
    def make(self) -> TextBlob: ...

class TextEncoding:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    kGlyphID: ClassVar[TextEncoding] = ...
    kUTF16: ClassVar[TextEncoding] = ...
    kUTF32: ClassVar[TextEncoding] = ...
    kUTF8: ClassVar[TextEncoding] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class TileImageFilter:
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def Make(cls, src: Rect, dst: Rect, input: ImageFilter = ...) -> ImageFilter: ...

class TileMode:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    kClamp: ClassVar[TileMode] = ...
    kDecal: ClassVar[TileMode] = ...
    kLastTileMode: ClassVar[TileMode] = ...
    kMirror: ClassVar[TileMode] = ...
    kRepeat: ClassVar[TileMode] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class TrimPathEffect:
    class Mode:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        kInverted: ClassVar[TrimPathEffect.Mode] = ...
        kNormal: ClassVar[TrimPathEffect.Mode] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    kInverted: ClassVar[TrimPathEffect.Mode] = ...
    kNormal: ClassVar[TrimPathEffect.Mode] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def Make(cls, startT: float, stopT: float, mode: TrimPathEffect.Mode = ...) -> PathEffect: ...

class Typeface(RefCnt):
    class SerializeBehavior:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        kDoIncludeData: ClassVar[Typeface.SerializeBehavior] = ...
        kDontIncludeData: ClassVar[Typeface.SerializeBehavior] = ...
        kIncludeDataIfLocal: ClassVar[Typeface.SerializeBehavior] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    kDoIncludeData: ClassVar[Typeface.SerializeBehavior] = ...
    kDontIncludeData: ClassVar[Typeface.SerializeBehavior] = ...
    kIncludeDataIfLocal: ClassVar[Typeface.SerializeBehavior] = ...
    __hash__: ClassVar[None] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, familyName: object, fontStyle: FontStyle = ...) -> None: ...
    def Equal(self: Typeface, other: Typeface) -> bool: ...
    @classmethod
    def MakeDefault(cls) -> Typeface: ...
    @classmethod
    def MakeDeserialize(cls, dats: Data) -> Typeface: ...
    @classmethod
    def MakeFromData(cls, data: Data, index: int = ...) -> Typeface: ...
    @classmethod
    def MakeFromFile(cls, path: str, index: int = ...) -> Typeface: ...
    @classmethod
    def MakeFromName(cls, familyName: object, fontStyle: FontStyle = ...) -> Typeface: ...
    @classmethod
    def UniqueID(cls, typeface: Typeface) -> int: ...
    def copyTableData(self, tag: int) -> Data: ...
    def countGlyphs(self) -> int: ...
    def countTables(self) -> int: ...
    def fontStyle(self) -> FontStyle: ...
    def getBounds(self) -> Rect: ...
    def getFamilyName(self) -> str: ...
    def getFamilyNames(self) -> list: ...
    def getKerningPairAdjustments(self, glyphs: List[int]) -> object: ...
    def getPostScriptName(self) -> str: ...
    def getTableData(self, tag: int) -> bytes: ...
    def getTableSize(self, tag: int) -> int: ...
    def getTableTags(self) -> List[int]: ...
    def getUnitsPerEm(self) -> int: ...
    def getVariationDesignParameters(self) -> List[FontParameters.Variation.Axis]: ...
    def getVariationDesignPosition(self) -> FontArguments.VariationPosition.Coordinates: ...
    def isBold(self) -> bool: ...
    def isFixedPitch(self) -> bool: ...
    def isItalic(self) -> bool: ...
    def makeClone(self, fontArguments: FontArguments) -> Typeface: ...
    def serialize(self, behavior: Typeface.SerializeBehavior = ...) -> Data: ...
    def unicharToGlyph(self, unichar: int) -> int: ...
    def unicharsToGlyphs(self, chars: List[int]) -> List[int]: ...
    def uniqueID(self) -> int: ...
    def __eq__(self, arg0: Typeface) -> bool: ...

class Vertices:
    class VertexMode:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        kLast_VertexMode: ClassVar[Vertices.VertexMode] = ...
        kTriangleFan_VertexMode: ClassVar[Vertices.VertexMode] = ...
        kTriangleStrip_VertexMode: ClassVar[Vertices.VertexMode] = ...
        kTriangles_VertexMode: ClassVar[Vertices.VertexMode] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    kLast_VertexMode: ClassVar[Vertices.VertexMode] = ...
    kTriangleFan_VertexMode: ClassVar[Vertices.VertexMode] = ...
    kTriangleStrip_VertexMode: ClassVar[Vertices.VertexMode] = ...
    kTriangles_VertexMode: ClassVar[Vertices.VertexMode] = ...
    def __init__(self, mode: Vertices.VertexMode, positions: List[Point], texs: object = ..., colors: object = ..., indices: object = ...) -> None: ...
    @classmethod
    def MakeCopy(cls, mode: Vertices.VertexMode, positions: List[Point], texs: object = ..., colors: object = ..., indices: object = ...) -> Vertices: ...
    def approximateSize(self) -> int: ...
    def bounds(self) -> Rect: ...
    def deref(self) -> None: ...
    def ref(self) -> None: ...
    def refCntGreaterThan(self, count: int) -> bool: ...
    def unique(self) -> bool: ...
    def uniqueID(self) -> int: ...
    def unref(self) -> None: ...

class VkFormat:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __and__(self, other: object) -> object: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __invert__(self) -> object: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __or__(self, other: object) -> object: ...
    def __rand__(self, other: object) -> object: ...
    def __ror__(self, other: object) -> object: ...
    def __rxor__(self, other: object) -> object: ...
    def __setstate__(self, state: int) -> None: ...
    def __xor__(self, other: object) -> object: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class VkImageLayout:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __and__(self, other: object) -> object: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __invert__(self) -> object: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __or__(self, other: object) -> object: ...
    def __rand__(self, other: object) -> object: ...
    def __ror__(self, other: object) -> object: ...
    def __rxor__(self, other: object) -> object: ...
    def __setstate__(self, state: int) -> None: ...
    def __xor__(self, other: object) -> object: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class WStream:
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def SizeOfPackedUInt(cls, value: int) -> int: ...
    def bytesWritten(self) -> int: ...
    def flush(self) -> None: ...
    def newline(self) -> bool: ...
    def write(self, buffer: buffer) -> bool: ...
    def write16(self, value: int) -> bool: ...
    def write32(self, value: int) -> bool: ...
    def write8(self, value: int) -> bool: ...
    def writeBigDecAsText(self, value: int, minDigits: int = ...) -> bool: ...
    @overload
    def writeBool(self, value: bool) -> bool: ...
    @overload
    def writeBool(self, value: bool) -> bool: ...
    def writeDecAsText(self, value: int) -> bool: ...
    def writeHexAsText(self, value: int, minDigits: int = ...) -> bool: ...
    def writePackedUInt(self, value: int) -> bool: ...
    def writeScalar(self, value: float) -> bool: ...
    def writeScalarAsText(self, value: float) -> bool: ...
    def writeStream(self, input: Stream, length: int) -> bool: ...
    def writeText(self, text: str) -> bool: ...

class XfermodeImageFilter:
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def Make(cls, mode: BlendMode, background: ImageFilter = ..., foreground: ImageFilter = ..., cropRect: ImageFilter.CropRect = ...) -> ImageFilter: ...

class YUVAIndex:
    class Index:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        kA_Index: ClassVar[YUVAIndex.Index] = ...
        kLast_Index: ClassVar[YUVAIndex.Index] = ...
        kU_Index: ClassVar[YUVAIndex.Index] = ...
        kV_Index: ClassVar[YUVAIndex.Index] = ...
        kY_Index: ClassVar[YUVAIndex.Index] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    kIndexCount: ClassVar[int] = ...  # read-only
    kA_Index: ClassVar[YUVAIndex.Index] = ...
    kLast_Index: ClassVar[YUVAIndex.Index] = ...
    kU_Index: ClassVar[YUVAIndex.Index] = ...
    kV_Index: ClassVar[YUVAIndex.Index] = ...
    kY_Index: ClassVar[YUVAIndex.Index] = ...
    __hash__: ClassVar[None] = ...
    fChannel: ColorChannel
    fIndex: int
    def __init__(self) -> None: ...
    @classmethod
    def AreValidIndices(cls, yuvaIndices: List[YUVAIndex], returnNumPlanes: bool = ...) -> object: ...
    def __eq__(self, arg0: YUVAIndex) -> bool: ...
    def __ne__(self, arg0: YUVAIndex) -> bool: ...

class YUVAInfo:
    class PlanarConfig:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        kUYVA_4444: ClassVar[YUVAInfo.PlanarConfig] = ...
        kUYV_444: ClassVar[YUVAInfo.PlanarConfig] = ...
        kYUVA_4444: ClassVar[YUVAInfo.PlanarConfig] = ...
        kYUV_444: ClassVar[YUVAInfo.PlanarConfig] = ...
        kY_UV_420: ClassVar[YUVAInfo.PlanarConfig] = ...
        kY_UV_A_4204: ClassVar[YUVAInfo.PlanarConfig] = ...
        kY_U_V_410: ClassVar[YUVAInfo.PlanarConfig] = ...
        kY_U_V_411: ClassVar[YUVAInfo.PlanarConfig] = ...
        kY_U_V_420: ClassVar[YUVAInfo.PlanarConfig] = ...
        kY_U_V_422: ClassVar[YUVAInfo.PlanarConfig] = ...
        kY_U_V_440: ClassVar[YUVAInfo.PlanarConfig] = ...
        kY_U_V_444: ClassVar[YUVAInfo.PlanarConfig] = ...
        kY_U_V_A_4204: ClassVar[YUVAInfo.PlanarConfig] = ...
        kY_VU_420: ClassVar[YUVAInfo.PlanarConfig] = ...
        kY_VU_A_4204: ClassVar[YUVAInfo.PlanarConfig] = ...
        kY_V_U_420: ClassVar[YUVAInfo.PlanarConfig] = ...
        kY_V_U_A_4204: ClassVar[YUVAInfo.PlanarConfig] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class Siting:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        kCentered: ClassVar[YUVAInfo.Siting] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    kMaxPlanes: ClassVar[int] = ...  # read-only
    kCentered: ClassVar[YUVAInfo.Siting] = ...
    kUYVA_4444: ClassVar[YUVAInfo.PlanarConfig] = ...
    kUYV_444: ClassVar[YUVAInfo.PlanarConfig] = ...
    kYUVA_4444: ClassVar[YUVAInfo.PlanarConfig] = ...
    kYUV_444: ClassVar[YUVAInfo.PlanarConfig] = ...
    kY_UV_420: ClassVar[YUVAInfo.PlanarConfig] = ...
    kY_UV_A_4204: ClassVar[YUVAInfo.PlanarConfig] = ...
    kY_U_V_410: ClassVar[YUVAInfo.PlanarConfig] = ...
    kY_U_V_411: ClassVar[YUVAInfo.PlanarConfig] = ...
    kY_U_V_420: ClassVar[YUVAInfo.PlanarConfig] = ...
    kY_U_V_422: ClassVar[YUVAInfo.PlanarConfig] = ...
    kY_U_V_440: ClassVar[YUVAInfo.PlanarConfig] = ...
    kY_U_V_444: ClassVar[YUVAInfo.PlanarConfig] = ...
    kY_U_V_A_4204: ClassVar[YUVAInfo.PlanarConfig] = ...
    kY_VU_420: ClassVar[YUVAInfo.PlanarConfig] = ...
    kY_VU_A_4204: ClassVar[YUVAInfo.PlanarConfig] = ...
    kY_V_U_420: ClassVar[YUVAInfo.PlanarConfig] = ...
    kY_V_U_A_4204: ClassVar[YUVAInfo.PlanarConfig] = ...
    __hash__: ClassVar[None] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, dimensions: ISize, config: YUVAInfo.PlanarConfig, yuvColorSpace: YUVColorSpace, origin: EncodedOrigin = ..., sittingX: YUVAInfo.Siting = ..., sittingY: YUVAInfo.Siting = ...) -> None: ...
    @classmethod
    def HasAlpha(cls, config: YUVAInfo.PlanarConfig) -> bool: ...
    @classmethod
    def NumChannelsInPlane(cls, config: YUVAInfo.PlanarConfig, i: int) -> int: ...
    @classmethod
    def NumPlanes(cls, config: YUVAInfo.PlanarConfig) -> int: ...
    @classmethod
    def PlaneDimensions(cls, imageDimensions: ISize, config: YUVAInfo.PlanarConfig, origin: EncodedOrigin) -> List[ISize]: ...
    def computeTotalBytes(self, rowBytes: List[int], returnPlaneSizes: bool = ...) -> object: ...
    def dimensions(self) -> ISize: ...
    def hasAlpha(self) -> bool: ...
    def height(self) -> int: ...
    def numChannelsInPlane(self, i: int) -> int: ...
    def numPlanes(self) -> int: ...
    def origin(self) -> EncodedOrigin: ...
    def planarConfig(self) -> YUVAInfo.PlanarConfig: ...
    def planeDimensions(self) -> List[ISize]: ...
    def sitingX(self) -> YUVAInfo.Siting: ...
    def sitingY(self) -> YUVAInfo.Siting: ...
    def width(self) -> int: ...
    def yuvColorSpace(self) -> YUVColorSpace: ...
    def __eq__(self, arg0: YUVAInfo) -> bool: ...
    def __ne__(self, arg0: YUVAInfo) -> bool: ...

class YUVAPixmapInfo:
    class DataType:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        kFloat16: ClassVar[YUVAPixmapInfo.DataType] = ...
        kLast: ClassVar[YUVAPixmapInfo.DataType] = ...
        kUnorm10_Unorm2: ClassVar[YUVAPixmapInfo.DataType] = ...
        kUnorm16: ClassVar[YUVAPixmapInfo.DataType] = ...
        kUnorm8: ClassVar[YUVAPixmapInfo.DataType] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class SupportedDataTypes:
        @overload
        def __init__(self) -> None: ...
        @overload
        def __init__(self, context: GrImageContext) -> None: ...
        @classmethod
        def All(cls) -> YUVAPixmapInfo.SupportedDataTypes: ...
        def enableDataType(self, dataType: YUVAPixmapInfo.DataType, numChannels: int) -> None: ...
        def supported(self, planarConfig: YUVAInfo.PlanarConfig, dataType: YUVAPixmapInfo.DataType) -> bool: ...
    kMaxPlanes: ClassVar[int] = ...  # read-only
    kFloat16: ClassVar[YUVAPixmapInfo.DataType] = ...
    kLast: ClassVar[YUVAPixmapInfo.DataType] = ...
    kUnorm10_Unorm2: ClassVar[YUVAPixmapInfo.DataType] = ...
    kUnorm16: ClassVar[YUVAPixmapInfo.DataType] = ...
    kUnorm8: ClassVar[YUVAPixmapInfo.DataType] = ...
    __hash__: ClassVar[None] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, info: YUVAInfo, colorType: List[ColorType], rowBytes: object = ...) -> None: ...
    @overload
    def __init__(self, info: YUVAInfo, dataType: YUVAPixmapInfo.DataType, rowBytes: object = ...) -> None: ...
    @classmethod
    def DefaultColorTypeForDataType(cls, dataType: YUVAPixmapInfo.DataType, numChannels: int) -> ColorType: ...
    @classmethod
    def NumChannelsAndDataType(cls, colorType: ColorType) -> Tuple[int,YUVAPixmapInfo.DataType]: ...
    def computeTotalBytes(self, returnPlaneSizes: bool = ...) -> object: ...
    def dataType(self) -> YUVAPixmapInfo.DataType: ...
    def initPixmapsFromSingleAllocation(self, memory: buffer) -> List[Pixmap]: ...
    def isSupported(self, supportedDataTypes: YUVAPixmapInfo.SupportedDataTypes) -> bool: ...
    def isValid(self) -> bool: ...
    def numPlanes(self) -> int: ...
    def planeInfo(self, i: int) -> ImageInfo: ...
    def rowBytes(self, i: int) -> int: ...
    def yuvColorSpace(self) -> YUVColorSpace: ...
    def yuvaInfo(self) -> YUVAInfo: ...
    def __eq__(self, arg0: YUVAPixmapInfo) -> bool: ...
    def __ne__(self, arg0: YUVAPixmapInfo) -> bool: ...

class YUVAPixmaps:
    def __init__(self) -> None: ...
    @classmethod
    def Allocate(cls, yuvaPixmapInfo: YUVAPixmapInfo) -> YUVAPixmaps: ...
    @classmethod
    def FromData(cls, yuvaPixmapInfo: YUVAPixmapInfo, data: Data) -> YUVAPixmaps: ...
    @classmethod
    def FromExternalMemory(cls, yuvaPixmapInfo: YUVAPixmapInfo, memory: buffer) -> YUVAPixmaps: ...
    @classmethod
    def FromExternalPixmaps(cls, yuvaInfo: YUVAInfo, pixmaps: List[Pixmap]) -> YUVAPixmaps: ...
    def isValid(self) -> bool: ...
    def numPlanes(self) -> int: ...
    def plane(self, i: int) -> Pixmap: ...
    def planes(self) -> List[skia.Pixmap[4]]: ...
    def toLegacy(self) -> tuple: ...
    def yuvaInfo(self) -> YUVAInfo: ...

class YUVASizeInfo:
    __hash__: ClassVar[None] = ...
    fOrigin: EncodedOrigin
    fSizes: List[ISize]
    fWidthBytes: List[int]
    def __init__(self) -> None: ...
    def computeTotalBytes(self) -> int: ...
    def __eq__(self, arg0: YUVASizeInfo) -> bool: ...

class YUVColorSpace:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    kBT2020_YUVColorSpace: ClassVar[YUVColorSpace] = ...
    kIdentity_YUVColorSpace: ClassVar[YUVColorSpace] = ...
    kJPEG_YUVColorSpace: ClassVar[YUVColorSpace] = ...
    kLastEnum_YUVColorSpace: ClassVar[YUVColorSpace] = ...
    kRec601_YUVColorSpace: ClassVar[YUVColorSpace] = ...
    kRec709_YUVColorSpace: ClassVar[YUVColorSpace] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class _AutoDocumentPage:
    def __init__(self, *args, **kwargs) -> None: ...
    def __enter__(self) -> SkCanvas: ...
    def __exit__(self, arg0: object, arg1: object, arg2: object) -> None: ...

def AlphaTypeIsOpaque(at: AlphaType) -> bool: ...
def AsWinding(path: Path) -> Path: ...
def BlendMode_AsCoeff(mode: BlendMode, src: BlendModeCoeff, dst: BlendModeCoeff) -> bool: ...
def BlendMode_Name(blendMode: BlendMode) -> str: ...
def Color(r: int, g: int, b: int, a: int = ...) -> int: ...
def ColorGetA(color: int) -> int: ...
def ColorGetB(color: int) -> int: ...
def ColorGetG(color: int) -> int: ...
def ColorGetR(color: int) -> int: ...
def ColorSetA(c: int, a: int) -> int: ...
def ColorSetARGB(a: int, r: int, g: int, b: int) -> int: ...
def ColorSetRGB(r: int, g: int, b: int) -> int: ...
def ColorToHSV(color: int) -> List[float]: ...
def ColorTypeBytesPerPixel(ct: ColorType) -> int: ...
def ColorTypeIsAlwaysOpaque(ct: ColorType) -> bool: ...
def ColorTypeValidateAlphaType(colorType: ColorType, alphaType: AlphaType, canonical: AlphaType = ...) -> bool: ...
def ComputeIsOpaque(bm: Bitmap) -> bool: ...
def EncodedOriginToMatrix(origin: EncodedOrigin, w: int, h: int) -> Matrix: ...
def HSVToColor(hsv: List[float], alpha: int = ...) -> int: ...
def MakeNullCanvas() -> Canvas: ...
def Op(one: Path, two: Path, op: PathOp) -> Path: ...
def PathFillType_ConvertToNonInverse(ft: PathFillType) -> PathFillType: ...
def PathFillType_IsEvenOdd(ft: PathFillType) -> bool: ...
def PathFillType_IsInverse(ft: PathFillType) -> bool: ...
def PreMultiplyARGB(a: int, r: int, g: int, b: int) -> int: ...
def PreMultiplyColor(c: int) -> int: ...
def RGBToHSV(red: int, green: int, blue: int) -> List[float]: ...
def Simplify(path: Path) -> Path: ...
def TightBounds(path: Path) -> Rect: ...
